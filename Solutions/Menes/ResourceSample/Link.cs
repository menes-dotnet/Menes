//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace Marain.LineOfBusiness
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Linq;
    using System.Text;
    using System.Text.Json;
    using System.Text.RegularExpressions;
    using Menes.Json;

    /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct Link : IJsonObject<Link>, IEquatable<Link>
    {
        /// <summary>
        /// JSON property name for <see cref = "Href"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> HrefUtf8JsonPropertyName = new byte[]{104, 114, 101, 102};
        /// <summary>
        /// JSON property name for <see cref = "Href"/>.
        /// </summary>
        public static readonly string HrefJsonPropertyName = "href";
        /// <summary>
        /// JSON property name for <see cref = "Templated"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> TemplatedUtf8JsonPropertyName = new byte[]{116, 101, 109, 112, 108, 97, 116, 101, 100};
        /// <summary>
        /// JSON property name for <see cref = "Templated"/>.
        /// </summary>
        public static readonly string TemplatedJsonPropertyName = "templated";
        /// <summary>
        /// JSON property name for <see cref = "Type"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> TypeUtf8JsonPropertyName = new byte[]{116, 121, 112, 101};
        /// <summary>
        /// JSON property name for <see cref = "Type"/>.
        /// </summary>
        public static readonly string TypeJsonPropertyName = "type";
        /// <summary>
        /// JSON property name for <see cref = "Name"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> NameUtf8JsonPropertyName = new byte[]{110, 97, 109, 101};
        /// <summary>
        /// JSON property name for <see cref = "Name"/>.
        /// </summary>
        public static readonly string NameJsonPropertyName = "name";
        /// <summary>
        /// JSON property name for <see cref = "Profile"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ProfileUtf8JsonPropertyName = new byte[]{112, 114, 111, 102, 105, 108, 101};
        /// <summary>
        /// JSON property name for <see cref = "Profile"/>.
        /// </summary>
        public static readonly string ProfileJsonPropertyName = "profile";
        /// <summary>
        /// JSON property name for <see cref = "Description"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> DescriptionUtf8JsonPropertyName = new byte[]{100, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110};
        /// <summary>
        /// JSON property name for <see cref = "Description"/>.
        /// </summary>
        public static readonly string DescriptionJsonPropertyName = "description";
        /// <summary>
        /// JSON property name for <see cref = "Hreflang"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> HreflangUtf8JsonPropertyName = new byte[]{104, 114, 101, 102, 108, 97, 110, 103};
        /// <summary>
        /// JSON property name for <see cref = "Hreflang"/>.
        /// </summary>
        public static readonly string HreflangJsonPropertyName = "hreflang";
        private static readonly ImmutableDictionary<string, Func<Link, ValidationContext, ValidationLevel, ValidationContext>> __MenesLocalProperties = CreateLocalPropertyValidators();
        private static readonly ImmutableDictionary<string, JsonAny> __MenesDefaults = BuildDefaults();
        private readonly JsonElement jsonElementBacking;
        private readonly ImmutableDictionary<string, JsonAny>? objectBacking;
        /// <summary>
        /// Initializes a new instance of the <see cref = "Link"/> struct.
        /// </summary>
        /// <param name = "value">The backing <see cref = "JsonElement"/>.</param>
        public Link(JsonElement value)
        {
            this.jsonElementBacking = value;
            this.objectBacking = default;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref = "Link"/> struct.
        /// </summary>
        /// <param name = "value">A property dictionary.</param>
        public Link(ImmutableDictionary<string, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref = "Link"/> struct.
        /// </summary>
        /// <param name = "jsonObject">The <see cref = "JsonObject"/> from which to construct the value.</param>
        public Link(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }
        }

        /// <summary>
        /// Gets Href.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.JsonString Href
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if (properties.TryGetValue(HrefJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(HrefUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new Menes.Json.JsonString(result);
                    }
                }

                return default;
            }
        }

        /// <summary>
        /// Gets Templated.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Marain.LineOfBusiness.Link.TemplatedValue Templated
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if (properties.TryGetValue(TemplatedJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(TemplatedUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new Marain.LineOfBusiness.Link.TemplatedValue(result);
                    }
                }

                return default;
            }
        }

        /// <summary>
        /// Gets Type.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Marain.LineOfBusiness.Link.TypeValue Type
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if (properties.TryGetValue(TypeJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(TypeUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new Marain.LineOfBusiness.Link.TypeValue(result);
                    }
                }

                return default;
            }
        }

        /// <summary>
        /// Gets Name.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.JsonString Name
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if (properties.TryGetValue(NameJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(NameUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new Menes.Json.JsonString(result);
                    }
                }

                return default;
            }
        }

        /// <summary>
        /// Gets Profile.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.JsonUri Profile
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if (properties.TryGetValue(ProfileJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ProfileUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new Menes.Json.JsonUri(result);
                    }
                }

                return default;
            }
        }

        /// <summary>
        /// Gets Description.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.JsonString Description
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if (properties.TryGetValue(DescriptionJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(DescriptionUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new Menes.Json.JsonString(result);
                    }
                }

                return default;
            }
        }

        /// <summary>
        /// Gets Hreflang.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Marain.LineOfBusiness.Link.HreflangValue Hreflang
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if (properties.TryGetValue(HreflangJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(HreflangUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new Marain.LineOfBusiness.Link.HreflangValue(result);
                    }
                }

                return default;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement => this.objectBacking is null;
        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref = "JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref = "JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref = "JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref = "JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref = "JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref = "JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator Link(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new Link(value.AsJsonElement);
            }

            return value.As<Link>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator JsonAny(Link value)
        {
            return value.AsAny;
        }

        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator Link(JsonObject value)
        {
            return new Link(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator JsonObject(Link value)
        {
            return value.AsObject;
        }

        /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<string, JsonAny>(Link value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator Link(ImmutableDictionary<string, JsonAny> value)
        {
            return new Link(value);
        }

        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name = "lhs">The left hand side of the comparison.</param>
        /// <param name = "rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(Link lhs, Link rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name = "lhs">The left hand side of the comparison.</param>
        /// <param name = "rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(Link lhs, Link rhs)
        {
            return !lhs.Equals(rhs);
        }

        /// <summary>
        /// Creates an instance of a <see cref = "Link"/>.
        /// </summary>
        public static Link Create(Menes.Json.JsonString href, Marain.LineOfBusiness.Link.TemplatedValue? templated = null, Marain.LineOfBusiness.Link.TypeValue? type = null, Menes.Json.JsonString? name = null, Menes.Json.JsonUri? profile = null, Menes.Json.JsonString? description = null, Marain.LineOfBusiness.Link.HreflangValue? hreflang = null)
        {
            var builder = ImmutableDictionary.CreateBuilder<string, JsonAny>();
            builder.Add(HrefJsonPropertyName, href);
            if (templated is Marain.LineOfBusiness.Link.TemplatedValue templated__)
            {
                builder.Add(TemplatedJsonPropertyName, templated__);
            }

            if (type is Marain.LineOfBusiness.Link.TypeValue type__)
            {
                builder.Add(TypeJsonPropertyName, type__);
            }

            if (name is Menes.Json.JsonString name__)
            {
                builder.Add(NameJsonPropertyName, name__);
            }

            if (profile is Menes.Json.JsonUri profile__)
            {
                builder.Add(ProfileJsonPropertyName, profile__);
            }

            if (description is Menes.Json.JsonString description__)
            {
                builder.Add(DescriptionJsonPropertyName, description__);
            }

            if (hreflang is Marain.LineOfBusiness.Link.HreflangValue hreflang__)
            {
                builder.Add(HreflangJsonPropertyName, hreflang__);
            }

            return builder.ToImmutable();
        }

        /// <summary>
        /// Sets href.
        /// </summary>
        /// <param name = "value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Link WithHref(Menes.Json.JsonString value)
        {
            return this.SetProperty(HrefJsonPropertyName, value);
        }

        /// <summary>
        /// Sets templated.
        /// </summary>
        /// <param name = "value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Link WithTemplated(Marain.LineOfBusiness.Link.TemplatedValue value)
        {
            return this.SetProperty(TemplatedJsonPropertyName, value);
        }

        /// <summary>
        /// Sets type.
        /// </summary>
        /// <param name = "value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Link WithType(Marain.LineOfBusiness.Link.TypeValue value)
        {
            return this.SetProperty(TypeJsonPropertyName, value);
        }

        /// <summary>
        /// Sets name.
        /// </summary>
        /// <param name = "value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Link WithName(Menes.Json.JsonString value)
        {
            return this.SetProperty(NameJsonPropertyName, value);
        }

        /// <summary>
        /// Sets profile.
        /// </summary>
        /// <param name = "value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Link WithProfile(Menes.Json.JsonUri value)
        {
            return this.SetProperty(ProfileJsonPropertyName, value);
        }

        /// <summary>
        /// Sets description.
        /// </summary>
        /// <param name = "value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Link WithDescription(Menes.Json.JsonString value)
        {
            return this.SetProperty(DescriptionJsonPropertyName, value);
        }

        /// <summary>
        /// Sets hreflang.
        /// </summary>
        /// <param name = "value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Link WithHreflang(Marain.LineOfBusiness.Link.HreflangValue value)
        {
            return this.SetProperty(HreflangJsonPropertyName, value);
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is Link entity)
            {
                return this.Equals(entity);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;
            return valueKind switch
            {
            JsonValueKind.Object => this.AsObject.GetHashCode(), JsonValueKind.Array => this.AsArray.GetHashCode(), JsonValueKind.Number => this.AsNumber.GetHashCode(), JsonValueKind.String => this.AsString.GetHashCode(), JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(), JsonValueKind.Null => JsonNull.NullHashCode, _ => 0, }

            ;
        }

        /// <summary>
        /// Writes the object to the <see cref = "Utf8JsonWriter"/>.
        /// </summary>
        /// <param name = "writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(string name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<char> name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(name.ToString(), out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(Encoding.UTF8.GetString(utf8name), out value);
        }

        /// <inheritdoc/>
        public bool HasDefault(string name)
        {
            return __MenesDefaults.TryGetValue(name, out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<char> name)
        {
            return __MenesDefaults.TryGetValue(name.ToString(), out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<byte> utf8name)
        {
            return __MenesDefaults.TryGetValue(Encoding.UTF8.GetString(utf8name), out _);
        }

        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;
            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
            JsonValueKind.Object => this.AsObject.Equals(other.AsObject()), JsonValueKind.Array => this.AsArray.Equals(other.AsArray()), JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()), JsonValueKind.String => this.AsString.Equals(other.AsString()), JsonValueKind.Null => true, JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()), _ => false, }

            ;
        }

        /// <inheritdoc/>
        public bool Equals(Link other)
        {
            JsonValueKind valueKind = this.ValueKind;
            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
            JsonValueKind.Object => this.AsObject.Equals(other.AsObject), JsonValueKind.Array => this.AsArray.Equals(other.AsArray), JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber), JsonValueKind.String => this.AsString.Equals(other.AsString), JsonValueKind.Null => true, JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean), _ => false, }

            ;
        }

        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name.ToString(), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(Encoding.UTF8.GetString(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public Link SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Link SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Link SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Link RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Link RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Link RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<Link, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }

            JsonValueKind valueKind = this.ValueKind;
            result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

            result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

            return result;
        }

        private static ImmutableDictionary<string, JsonAny> BuildDefaults()
        {
            ImmutableDictionary<string, JsonAny>.Builder builder = ImmutableDictionary.CreateBuilder<string, JsonAny>();
            builder.Add(TemplatedJsonPropertyName, JsonAny.Parse("false"));
            return builder.ToImmutable();
        }

        private static ImmutableDictionary<string, Func<Link, ValidationContext, ValidationLevel, ValidationContext>> CreateLocalPropertyValidators()
        {
            ImmutableDictionary<string, Func<Link, ValidationContext, ValidationLevel, ValidationContext>>.Builder builder = ImmutableDictionary.CreateBuilder<string, Func<Link, ValidationContext, ValidationLevel, ValidationContext>>();
            builder.Add(HrefJsonPropertyName, (that, validationContext, level) =>
            {
                Menes.Json.JsonString property = that.Href;
                return property.Validate(validationContext, level);
            });
            builder.Add(TemplatedJsonPropertyName, (that, validationContext, level) =>
            {
                Marain.LineOfBusiness.Link.TemplatedValue property = that.Templated;
                return property.Validate(validationContext, level);
            });
            builder.Add(TypeJsonPropertyName, (that, validationContext, level) =>
            {
                Marain.LineOfBusiness.Link.TypeValue property = that.Type;
                return property.Validate(validationContext, level);
            });
            builder.Add(NameJsonPropertyName, (that, validationContext, level) =>
            {
                Menes.Json.JsonString property = that.Name;
                return property.Validate(validationContext, level);
            });
            builder.Add(ProfileJsonPropertyName, (that, validationContext, level) =>
            {
                Menes.Json.JsonUri property = that.Profile;
                return property.Validate(validationContext, level);
            });
            builder.Add(DescriptionJsonPropertyName, (that, validationContext, level) =>
            {
                Menes.Json.JsonString property = that.Description;
                return property.Validate(validationContext, level);
            });
            builder.Add(HreflangJsonPropertyName, (that, validationContext, level) =>
            {
                Marain.LineOfBusiness.Link.HreflangValue property = that.Hreflang;
                return property.Validate(validationContext, level);
            });
            return builder.ToImmutable();
        }

        private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

            bool foundHref = false;
            foreach (Property property in this.EnumerateObject())
            {
                string propertyName = property.Name;
                if (__MenesLocalProperties.TryGetValue(propertyName, out Func<Link, ValidationContext, ValidationLevel, ValidationContext>? propertyValidator))
                {
                    result = result.WithLocalProperty(propertyName);
                    var propertyResult = propertyValidator(this, result, level);
                    result = result.MergeResults(propertyResult.IsValid, level, propertyResult);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }

                    if (HrefJsonPropertyName.Equals(propertyName))
                    {
                        foundHref = true;
                    }
                }
            }

            if (!foundHref && !HasDefault(HrefJsonPropertyName))
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.5.3. required - required property \"href\" not present.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.5.3. required - required property not present.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }
            }

            return result;
        }

        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

            result = result.MergeResults(isValid, level, localResultObject);
            return result;
        }

        /// <summary>
        /// A type generated from a JsonSchema specification.
        /// </summary>
        public readonly struct TemplatedValue : IJsonValue, IEquatable<TemplatedValue>
        {
            private readonly JsonElement jsonElementBacking;
            private readonly bool? booleanBacking;
            /// <summary>
            /// Initializes a new instance of the <see cref = "TemplatedValue"/> struct.
            /// </summary>
            /// <param name = "value">The backing <see cref = "JsonElement"/>.</param>
            public TemplatedValue(JsonElement value)
            {
                this.jsonElementBacking = value;
                this.booleanBacking = default;
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "TemplatedValue"/> struct.
            /// </summary>
            /// <param name = "jsonBoolean">The <see cref = "JsonBoolean"/> from which to construct the value.</param>
            public TemplatedValue(JsonBoolean jsonBoolean)
            {
                if (jsonBoolean.HasJsonElement)
                {
                    this.jsonElementBacking = jsonBoolean.AsJsonElement;
                    this.booleanBacking = default;
                }
                else
                {
                    this.jsonElementBacking = default;
                    this.booleanBacking = jsonBoolean.GetBoolean();
                }
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "TemplatedValue"/> struct.
            /// </summary>
            /// <param name = "boolean">The <see cref = "bool "/> from which to construct the value.</param>
            public TemplatedValue(bool boolean)
            {
                this.jsonElementBacking = default;
                this.booleanBacking = boolean;
            }

            /// <summary>
            /// Gets a value indicating whether this is backed by a JSON element.
            /// </summary>
            public bool HasJsonElement => this.booleanBacking is null;
            /// <summary>
            /// Gets the value as a JsonElement.
            /// </summary>
            public JsonElement AsJsonElement
            {
                get
                {
                    if (this.booleanBacking is bool booleanBacking)
                    {
                        return JsonBoolean.BoolToJsonElement(booleanBacking);
                    }

                    return this.jsonElementBacking;
                }
            }

            /// <inheritdoc/>
            public JsonValueKind ValueKind
            {
                get
                {
                    if (this.booleanBacking is bool booleanBacking)
                    {
                        return booleanBacking ? JsonValueKind.True : JsonValueKind.False;
                    }

                    return this.jsonElementBacking.ValueKind;
                }
            }

            /// <inheritdoc/>
            public JsonAny AsAny
            {
                get
                {
                    if (this.booleanBacking is bool booleanBacking)
                    {
                        return new JsonAny(booleanBacking);
                    }

                    return new JsonAny(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonObject"/>.
            /// </summary>
            public JsonObject AsObject
            {
                get
                {
                    return new JsonObject(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonArray"/>.
            /// </summary>
            public JsonArray AsArray
            {
                get
                {
                    return new JsonArray(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonNumber"/>.
            /// </summary>
            public JsonNumber AsNumber
            {
                get
                {
                    return new JsonNumber(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonString"/>.
            /// </summary>
            public JsonString AsString
            {
                get
                {
                    return new JsonString(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonBoolean"/>.
            /// </summary>
            public JsonBoolean AsBoolean
            {
                get
                {
                    if (this.booleanBacking is bool booleanBacking)
                    {
                        return new JsonBoolean(booleanBacking);
                    }

                    return new JsonBoolean(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonNull"/>.
            /// </summary>
            public JsonNull AsNull
            {
                get
                {
                    return default;
                }
            }

            /// <summary>
            /// Conversion from any.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TemplatedValue(JsonAny value)
            {
                if (value.HasJsonElement)
                {
                    return new TemplatedValue(value.AsJsonElement);
                }

                return value.As<TemplatedValue>();
            }

            /// <summary>
            /// Conversion to any.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator JsonAny(TemplatedValue value)
            {
                return value.AsAny;
            }

            /// <summary>
            /// Conversion from bool.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TemplatedValue(bool value)
            {
                return new TemplatedValue(value);
            }

            /// <summary>
            /// Conversion to bool.
            /// </summary>
            /// <param name = "boolean">The value from which to convert.</param>
            public static implicit operator bool (TemplatedValue boolean)
            {
                return boolean.AsBoolean.GetBoolean();
            }

            /// <summary>
            /// Conversion from bool.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TemplatedValue(JsonBoolean value)
            {
                return new TemplatedValue(value);
            }

            /// <summary>
            /// Conversion to bool.
            /// </summary>
            /// <param name = "boolean">The value from which to convert.</param>
            public static implicit operator JsonBoolean(TemplatedValue boolean)
            {
                return boolean.AsBoolean;
            }

            /// <summary>
            /// Standard equality operator.
            /// </summary>
            /// <param name = "lhs">The left hand side of the comparison.</param>
            /// <param name = "rhs">The right hand side of the comparison.</param>
            /// <returns>True if they are equal.</returns>
            public static bool operator ==(TemplatedValue lhs, TemplatedValue rhs)
            {
                return lhs.Equals(rhs);
            }

            /// <summary>
            /// Standard inequality operator.
            /// </summary>
            /// <param name = "lhs">The left hand side of the comparison.</param>
            /// <param name = "rhs">The right hand side of the comparison.</param>
            /// <returns>True if they are not equal.</returns>
            public static bool operator !=(TemplatedValue lhs, TemplatedValue rhs)
            {
                return !lhs.Equals(rhs);
            }

            /// <inheritdoc/>
            public override bool Equals(object? obj)
            {
                if (obj is TemplatedValue entity)
                {
                    return this.Equals(entity);
                }

                return false;
            }

            /// <inheritdoc/>
            public override int GetHashCode()
            {
                JsonValueKind valueKind = this.ValueKind;
                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.GetHashCode(), JsonValueKind.Array => this.AsArray.GetHashCode(), JsonValueKind.Number => this.AsNumber.GetHashCode(), JsonValueKind.String => this.AsString.GetHashCode(), JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(), JsonValueKind.Null => JsonNull.NullHashCode, _ => 0, }

                ;
            }

            /// <summary>
            /// Writes the object to the <see cref = "Utf8JsonWriter"/>.
            /// </summary>
            /// <param name = "writer">The writer to which to write the object.</param>
            public void WriteTo(Utf8JsonWriter writer)
            {
                if (this.booleanBacking is bool booleanBacking)
                {
                    writer.WriteBooleanValue(booleanBacking);
                    return;
                }

                if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
                {
                    this.jsonElementBacking.WriteTo(writer);
                    return;
                }

                writer.WriteNullValue();
            }

            /// <inheritdoc/>
            public bool Equals<T>(T other)
                where T : struct, IJsonValue
            {
                JsonValueKind valueKind = this.ValueKind;
                if (other.ValueKind != valueKind)
                {
                    return false;
                }

                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()), JsonValueKind.Array => this.AsArray.Equals(other.AsArray()), JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()), JsonValueKind.String => this.AsString.Equals(other.AsString()), JsonValueKind.Null => true, JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()), _ => false, }

                ;
            }

            /// <inheritdoc/>
            public bool Equals(TemplatedValue other)
            {
                JsonValueKind valueKind = this.ValueKind;
                if (other.ValueKind != valueKind)
                {
                    return false;
                }

                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject), JsonValueKind.Array => this.AsArray.Equals(other.AsArray), JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber), JsonValueKind.String => this.AsString.Equals(other.AsString), JsonValueKind.Null => true, JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean), _ => false, }

                ;
            }

            /// <inheritdoc/>
            public T As<T>()
                where T : struct, IJsonValue
            {
                return this.As<TemplatedValue, T>();
            }

            /// <inheritdoc/>
            public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
            {
                ValidationContext result = validationContext ?? ValidationContext.ValidContext;
                if (level != ValidationLevel.Flag)
                {
                    result = result.UsingStack();
                }

                JsonValueKind valueKind = this.ValueKind;
                result = this.ValidateType(valueKind, result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                return result;
            }

            private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
            {
                ValidationContext result = validationContext;
                bool isValid = false;
                ValidationContext localResultBoolean = Menes.Json.Validate.TypeBoolean(valueKind, result, level);
                if (level == ValidationLevel.Flag && localResultBoolean.IsValid)
                {
                    return validationContext;
                }

                if (localResultBoolean.IsValid)
                {
                    isValid = true;
                }

                result = result.MergeResults(isValid, level, localResultBoolean);
                return result;
            }
        }

        /// <summary>
        /// A type generated from a JsonSchema specification.
        /// </summary>
        public readonly struct TypeValue : IJsonValue, IEquatable<TypeValue>
        {
            private static readonly Regex __MenesPatternExpression = new Regex("^(application|audio|example|image|message|model|multipart|text|video)\\\\/[a-zA-Z0-9!#\\\\$&\\\\.\\\\+-\\\\^_]{1,127}$", RegexOptions.Compiled);
            private readonly JsonElement jsonElementBacking;
            private readonly string? stringBacking;
            /// <summary>
            /// Initializes a new instance of the <see cref = "TypeValue"/> struct.
            /// </summary>
            /// <param name = "value">The backing <see cref = "JsonElement"/>.</param>
            public TypeValue(JsonElement value)
            {
                this.jsonElementBacking = value;
                this.stringBacking = default;
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "TypeValue"/> struct.
            /// </summary>
            /// <param name = "value">A string value.</param>
            public TypeValue(string value)
            {
                this.jsonElementBacking = default;
                this.stringBacking = value;
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "TypeValue"/> struct.
            /// </summary>
            /// <param name = "value">A string value.</param>
            public TypeValue(ReadOnlySpan<char> value)
            {
                this.jsonElementBacking = default;
                this.stringBacking = value.ToString();
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "TypeValue"/> struct.
            /// </summary>
            /// <param name = "value">A string value.</param>
            public TypeValue(ReadOnlySpan<byte> value)
            {
                this.jsonElementBacking = default;
                this.stringBacking = Encoding.UTF8.GetString(value);
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "TypeValue"/> struct.
            /// </summary>
            /// <param name = "jsonString">The <see cref = "JsonString"/> from which to construct the value.</param>
            public TypeValue(JsonString jsonString)
            {
                if (jsonString.HasJsonElement)
                {
                    this.jsonElementBacking = jsonString.AsJsonElement;
                    this.stringBacking = default;
                }
                else
                {
                    this.jsonElementBacking = default;
                    this.stringBacking = jsonString;
                }
            }

            /// <summary>
            /// Gets a value indicating whether this is backed by a JSON element.
            /// </summary>
            public bool HasJsonElement => this.stringBacking is null;
            /// <summary>
            /// Gets the value as a JsonElement.
            /// </summary>
            public JsonElement AsJsonElement
            {
                get
                {
                    if (this.stringBacking is string stringBacking)
                    {
                        return JsonString.StringToJsonElement(stringBacking);
                    }

                    return this.jsonElementBacking;
                }
            }

            /// <inheritdoc/>
            public JsonValueKind ValueKind
            {
                get
                {
                    if (this.stringBacking is string)
                    {
                        return JsonValueKind.String;
                    }

                    return this.jsonElementBacking.ValueKind;
                }
            }

            /// <inheritdoc/>
            public JsonAny AsAny
            {
                get
                {
                    if (this.stringBacking is string stringBacking)
                    {
                        return new JsonAny(stringBacking);
                    }

                    return new JsonAny(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonObject"/>.
            /// </summary>
            public JsonObject AsObject
            {
                get
                {
                    return new JsonObject(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonArray"/>.
            /// </summary>
            public JsonArray AsArray
            {
                get
                {
                    return new JsonArray(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonNumber"/>.
            /// </summary>
            public JsonNumber AsNumber
            {
                get
                {
                    return new JsonNumber(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonString"/>.
            /// </summary>
            public JsonString AsString
            {
                get
                {
                    if (this.stringBacking is string stringBacking)
                    {
                        return new JsonString(stringBacking);
                    }

                    return new JsonString(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonBoolean"/>.
            /// </summary>
            public JsonBoolean AsBoolean
            {
                get
                {
                    return new JsonBoolean(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonNull"/>.
            /// </summary>
            public JsonNull AsNull
            {
                get
                {
                    return default;
                }
            }

            /// <summary>
            /// Conversion from any.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TypeValue(JsonAny value)
            {
                if (value.HasJsonElement)
                {
                    return new TypeValue(value.AsJsonElement);
                }

                return value.As<TypeValue>();
            }

            /// <summary>
            /// Conversion to any.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator JsonAny(TypeValue value)
            {
                return value.AsAny;
            }

            /// <summary>
            /// Conversion from string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TypeValue(string value)
            {
                return new TypeValue(value);
            }

            /// <summary>
            /// Conversion to string.
            /// </summary>
            /// <param name = "value">The number from which to convert.</param>
            public static implicit operator string (TypeValue value)
            {
                return value.AsString;
            }

            /// <summary>
            /// Conversion from string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TypeValue(ReadOnlySpan<char> value)
            {
                return new TypeValue(value);
            }

            /// <summary>
            /// Conversion to string.
            /// </summary>
            /// <param name = "value">The number from which to convert.</param>
            public static implicit operator ReadOnlySpan<char>(TypeValue value)
            {
                return value.AsString;
            }

            /// <summary>
            /// Conversion from utf8 bytes.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TypeValue(ReadOnlySpan<byte> value)
            {
                return new TypeValue(value);
            }

            /// <summary>
            /// Conversion to utf8 bytes.
            /// </summary>
            /// <param name = "value">The number from which to convert.</param>
            public static implicit operator ReadOnlySpan<byte>(TypeValue value)
            {
                return value.AsString;
            }

            /// <summary>
            /// Conversion from string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TypeValue(JsonString value)
            {
                return new TypeValue(value);
            }

            /// <summary>
            /// Conversion to string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator JsonString(TypeValue value)
            {
                return value.AsString;
            }

            /// <summary>
            /// Standard equality operator.
            /// </summary>
            /// <param name = "lhs">The left hand side of the comparison.</param>
            /// <param name = "rhs">The right hand side of the comparison.</param>
            /// <returns>True if they are equal.</returns>
            public static bool operator ==(TypeValue lhs, TypeValue rhs)
            {
                return lhs.Equals(rhs);
            }

            /// <summary>
            /// Standard inequality operator.
            /// </summary>
            /// <param name = "lhs">The left hand side of the comparison.</param>
            /// <param name = "rhs">The right hand side of the comparison.</param>
            /// <returns>True if they are not equal.</returns>
            public static bool operator !=(TypeValue lhs, TypeValue rhs)
            {
                return !lhs.Equals(rhs);
            }

            /// <inheritdoc/>
            public override bool Equals(object? obj)
            {
                if (obj is TypeValue entity)
                {
                    return this.Equals(entity);
                }

                return false;
            }

            /// <inheritdoc/>
            public override int GetHashCode()
            {
                JsonValueKind valueKind = this.ValueKind;
                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.GetHashCode(), JsonValueKind.Array => this.AsArray.GetHashCode(), JsonValueKind.Number => this.AsNumber.GetHashCode(), JsonValueKind.String => this.AsString.GetHashCode(), JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(), JsonValueKind.Null => JsonNull.NullHashCode, _ => 0, }

                ;
            }

            /// <summary>
            /// Writes the object to the <see cref = "Utf8JsonWriter"/>.
            /// </summary>
            /// <param name = "writer">The writer to which to write the object.</param>
            public void WriteTo(Utf8JsonWriter writer)
            {
                if (this.stringBacking is string stringBacking)
                {
                    writer.WriteStringValue(stringBacking);
                    return;
                }

                if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
                {
                    this.jsonElementBacking.WriteTo(writer);
                    return;
                }

                writer.WriteNullValue();
            }

            /// <inheritdoc/>
            public bool Equals<T>(T other)
                where T : struct, IJsonValue
            {
                JsonValueKind valueKind = this.ValueKind;
                if (other.ValueKind != valueKind)
                {
                    return false;
                }

                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()), JsonValueKind.Array => this.AsArray.Equals(other.AsArray()), JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()), JsonValueKind.String => this.AsString.Equals(other.AsString()), JsonValueKind.Null => true, JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()), _ => false, }

                ;
            }

            /// <inheritdoc/>
            public bool Equals(TypeValue other)
            {
                JsonValueKind valueKind = this.ValueKind;
                if (other.ValueKind != valueKind)
                {
                    return false;
                }

                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject), JsonValueKind.Array => this.AsArray.Equals(other.AsArray), JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber), JsonValueKind.String => this.AsString.Equals(other.AsString), JsonValueKind.Null => true, JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean), _ => false, }

                ;
            }

            /// <inheritdoc/>
            public T As<T>()
                where T : struct, IJsonValue
            {
                return this.As<TypeValue, T>();
            }

            /// <inheritdoc/>
            public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
            {
                ValidationContext result = validationContext ?? ValidationContext.ValidContext;
                if (level != ValidationLevel.Flag)
                {
                    result = result.UsingStack();
                }

                JsonValueKind valueKind = this.ValueKind;
                result = this.ValidateType(valueKind, result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                result = Menes.Json.Validate.ValidateString(this, result, level, null, null, __MenesPatternExpression);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                return result;
            }

            private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
            {
                ValidationContext result = validationContext;
                bool isValid = false;
                ValidationContext localResultString = Menes.Json.Validate.TypeString(valueKind, result, level);
                if (level == ValidationLevel.Flag && localResultString.IsValid)
                {
                    return validationContext;
                }

                if (localResultString.IsValid)
                {
                    isValid = true;
                }

                result = result.MergeResults(isValid, level, localResultString);
                return result;
            }
        }

        /// <summary>
        /// A type generated from a JsonSchema specification.
        /// </summary>
        public readonly struct HreflangValue : IJsonValue, IEquatable<HreflangValue>
        {
            private static readonly Regex __MenesPatternExpression = new Regex("^([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){0,2})?(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-([a-zA-Z0-9]{5,8}|[0-9][a-zA-Z0-9]{3}))*([0-9A-WY-Za-wy-z](-[a-zA-Z0-9]{2,8}){1,})*(x-[a-zA-Z0-9]{2,8})?)|(x-[a-zA-Z0-9]{2,8})|(en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE)|(art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang)$", RegexOptions.Compiled);
            private readonly JsonElement jsonElementBacking;
            private readonly string? stringBacking;
            /// <summary>
            /// Initializes a new instance of the <see cref = "HreflangValue"/> struct.
            /// </summary>
            /// <param name = "value">The backing <see cref = "JsonElement"/>.</param>
            public HreflangValue(JsonElement value)
            {
                this.jsonElementBacking = value;
                this.stringBacking = default;
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "HreflangValue"/> struct.
            /// </summary>
            /// <param name = "value">A string value.</param>
            public HreflangValue(string value)
            {
                this.jsonElementBacking = default;
                this.stringBacking = value;
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "HreflangValue"/> struct.
            /// </summary>
            /// <param name = "value">A string value.</param>
            public HreflangValue(ReadOnlySpan<char> value)
            {
                this.jsonElementBacking = default;
                this.stringBacking = value.ToString();
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "HreflangValue"/> struct.
            /// </summary>
            /// <param name = "value">A string value.</param>
            public HreflangValue(ReadOnlySpan<byte> value)
            {
                this.jsonElementBacking = default;
                this.stringBacking = Encoding.UTF8.GetString(value);
            }

            /// <summary>
            /// Initializes a new instance of the <see cref = "HreflangValue"/> struct.
            /// </summary>
            /// <param name = "jsonString">The <see cref = "JsonString"/> from which to construct the value.</param>
            public HreflangValue(JsonString jsonString)
            {
                if (jsonString.HasJsonElement)
                {
                    this.jsonElementBacking = jsonString.AsJsonElement;
                    this.stringBacking = default;
                }
                else
                {
                    this.jsonElementBacking = default;
                    this.stringBacking = jsonString;
                }
            }

            /// <summary>
            /// Gets a value indicating whether this is backed by a JSON element.
            /// </summary>
            public bool HasJsonElement => this.stringBacking is null;
            /// <summary>
            /// Gets the value as a JsonElement.
            /// </summary>
            public JsonElement AsJsonElement
            {
                get
                {
                    if (this.stringBacking is string stringBacking)
                    {
                        return JsonString.StringToJsonElement(stringBacking);
                    }

                    return this.jsonElementBacking;
                }
            }

            /// <inheritdoc/>
            public JsonValueKind ValueKind
            {
                get
                {
                    if (this.stringBacking is string)
                    {
                        return JsonValueKind.String;
                    }

                    return this.jsonElementBacking.ValueKind;
                }
            }

            /// <inheritdoc/>
            public JsonAny AsAny
            {
                get
                {
                    if (this.stringBacking is string stringBacking)
                    {
                        return new JsonAny(stringBacking);
                    }

                    return new JsonAny(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonObject"/>.
            /// </summary>
            public JsonObject AsObject
            {
                get
                {
                    return new JsonObject(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonArray"/>.
            /// </summary>
            public JsonArray AsArray
            {
                get
                {
                    return new JsonArray(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonNumber"/>.
            /// </summary>
            public JsonNumber AsNumber
            {
                get
                {
                    return new JsonNumber(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonString"/>.
            /// </summary>
            public JsonString AsString
            {
                get
                {
                    if (this.stringBacking is string stringBacking)
                    {
                        return new JsonString(stringBacking);
                    }

                    return new JsonString(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonBoolean"/>.
            /// </summary>
            public JsonBoolean AsBoolean
            {
                get
                {
                    return new JsonBoolean(this.jsonElementBacking);
                }
            }

            /// <summary>
            /// Gets the value as a <see cref = "JsonNull"/>.
            /// </summary>
            public JsonNull AsNull
            {
                get
                {
                    return default;
                }
            }

            /// <summary>
            /// Conversion from any.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator HreflangValue(JsonAny value)
            {
                if (value.HasJsonElement)
                {
                    return new HreflangValue(value.AsJsonElement);
                }

                return value.As<HreflangValue>();
            }

            /// <summary>
            /// Conversion to any.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator JsonAny(HreflangValue value)
            {
                return value.AsAny;
            }

            /// <summary>
            /// Conversion from string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator HreflangValue(string value)
            {
                return new HreflangValue(value);
            }

            /// <summary>
            /// Conversion to string.
            /// </summary>
            /// <param name = "value">The number from which to convert.</param>
            public static implicit operator string (HreflangValue value)
            {
                return value.AsString;
            }

            /// <summary>
            /// Conversion from string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator HreflangValue(ReadOnlySpan<char> value)
            {
                return new HreflangValue(value);
            }

            /// <summary>
            /// Conversion to string.
            /// </summary>
            /// <param name = "value">The number from which to convert.</param>
            public static implicit operator ReadOnlySpan<char>(HreflangValue value)
            {
                return value.AsString;
            }

            /// <summary>
            /// Conversion from utf8 bytes.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator HreflangValue(ReadOnlySpan<byte> value)
            {
                return new HreflangValue(value);
            }

            /// <summary>
            /// Conversion to utf8 bytes.
            /// </summary>
            /// <param name = "value">The number from which to convert.</param>
            public static implicit operator ReadOnlySpan<byte>(HreflangValue value)
            {
                return value.AsString;
            }

            /// <summary>
            /// Conversion from string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator HreflangValue(JsonString value)
            {
                return new HreflangValue(value);
            }

            /// <summary>
            /// Conversion to string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator JsonString(HreflangValue value)
            {
                return value.AsString;
            }

            /// <summary>
            /// Standard equality operator.
            /// </summary>
            /// <param name = "lhs">The left hand side of the comparison.</param>
            /// <param name = "rhs">The right hand side of the comparison.</param>
            /// <returns>True if they are equal.</returns>
            public static bool operator ==(HreflangValue lhs, HreflangValue rhs)
            {
                return lhs.Equals(rhs);
            }

            /// <summary>
            /// Standard inequality operator.
            /// </summary>
            /// <param name = "lhs">The left hand side of the comparison.</param>
            /// <param name = "rhs">The right hand side of the comparison.</param>
            /// <returns>True if they are not equal.</returns>
            public static bool operator !=(HreflangValue lhs, HreflangValue rhs)
            {
                return !lhs.Equals(rhs);
            }

            /// <inheritdoc/>
            public override bool Equals(object? obj)
            {
                if (obj is HreflangValue entity)
                {
                    return this.Equals(entity);
                }

                return false;
            }

            /// <inheritdoc/>
            public override int GetHashCode()
            {
                JsonValueKind valueKind = this.ValueKind;
                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.GetHashCode(), JsonValueKind.Array => this.AsArray.GetHashCode(), JsonValueKind.Number => this.AsNumber.GetHashCode(), JsonValueKind.String => this.AsString.GetHashCode(), JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(), JsonValueKind.Null => JsonNull.NullHashCode, _ => 0, }

                ;
            }

            /// <summary>
            /// Writes the object to the <see cref = "Utf8JsonWriter"/>.
            /// </summary>
            /// <param name = "writer">The writer to which to write the object.</param>
            public void WriteTo(Utf8JsonWriter writer)
            {
                if (this.stringBacking is string stringBacking)
                {
                    writer.WriteStringValue(stringBacking);
                    return;
                }

                if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
                {
                    this.jsonElementBacking.WriteTo(writer);
                    return;
                }

                writer.WriteNullValue();
            }

            /// <inheritdoc/>
            public bool Equals<T>(T other)
                where T : struct, IJsonValue
            {
                JsonValueKind valueKind = this.ValueKind;
                if (other.ValueKind != valueKind)
                {
                    return false;
                }

                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()), JsonValueKind.Array => this.AsArray.Equals(other.AsArray()), JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()), JsonValueKind.String => this.AsString.Equals(other.AsString()), JsonValueKind.Null => true, JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()), _ => false, }

                ;
            }

            /// <inheritdoc/>
            public bool Equals(HreflangValue other)
            {
                JsonValueKind valueKind = this.ValueKind;
                if (other.ValueKind != valueKind)
                {
                    return false;
                }

                return valueKind switch
                {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject), JsonValueKind.Array => this.AsArray.Equals(other.AsArray), JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber), JsonValueKind.String => this.AsString.Equals(other.AsString), JsonValueKind.Null => true, JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean), _ => false, }

                ;
            }

            /// <inheritdoc/>
            public T As<T>()
                where T : struct, IJsonValue
            {
                return this.As<HreflangValue, T>();
            }

            /// <inheritdoc/>
            public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
            {
                ValidationContext result = validationContext ?? ValidationContext.ValidContext;
                if (level != ValidationLevel.Flag)
                {
                    result = result.UsingStack();
                }

                JsonValueKind valueKind = this.ValueKind;
                result = this.ValidateType(valueKind, result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                result = Menes.Json.Validate.ValidateString(this, result, level, null, null, __MenesPatternExpression);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                return result;
            }

            private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
            {
                ValidationContext result = validationContext;
                bool isValid = false;
                ValidationContext localResultString = Menes.Json.Validate.TypeString(valueKind, result, level);
                if (level == ValidationLevel.Flag && localResultString.IsValid)
                {
                    return validationContext;
                }

                if (localResultString.IsValid)
                {
                    isValid = true;
                }

                result = result.MergeResults(isValid, level, localResultString);
                return result;
            }
        }
    }
}