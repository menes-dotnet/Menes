
    //------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace Menes.Json
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Text.Json;
    using System.Text.RegularExpressions;
    using Menes.Json;

        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct Applicator :
            IJsonObject<Applicator>,
                    IEquatable<Applicator>
    {
    
        
        /// <summary>
        /// JSON property name for <see cref="AdditionalItems"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> AdditionalItemsUtf8JsonPropertyName = new byte[] { 97, 100, 100, 105, 116, 105, 111, 110, 97, 108, 73, 116, 101, 109, 115 };

        /// <summary>
        /// JSON property name for <see cref="AdditionalItems"/>.
        /// </summary>
        public static readonly JsonEncodedText AdditionalItemsJsonPropertyName = JsonEncodedText.Encode( AdditionalItemsUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="UnevaluatedItems"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> UnevaluatedItemsUtf8JsonPropertyName = new byte[] { 117, 110, 101, 118, 97, 108, 117, 97, 116, 101, 100, 73, 116, 101, 109, 115 };

        /// <summary>
        /// JSON property name for <see cref="UnevaluatedItems"/>.
        /// </summary>
        public static readonly JsonEncodedText UnevaluatedItemsJsonPropertyName = JsonEncodedText.Encode( UnevaluatedItemsUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="Items"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ItemsUtf8JsonPropertyName = new byte[] { 105, 116, 101, 109, 115 };

        /// <summary>
        /// JSON property name for <see cref="Items"/>.
        /// </summary>
        public static readonly JsonEncodedText ItemsJsonPropertyName = JsonEncodedText.Encode( ItemsUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="Contains"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ContainsUtf8JsonPropertyName = new byte[] { 99, 111, 110, 116, 97, 105, 110, 115 };

        /// <summary>
        /// JSON property name for <see cref="Contains"/>.
        /// </summary>
        public static readonly JsonEncodedText ContainsJsonPropertyName = JsonEncodedText.Encode( ContainsUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="AdditionalProperties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> AdditionalPropertiesUtf8JsonPropertyName = new byte[] { 97, 100, 100, 105, 116, 105, 111, 110, 97, 108, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="AdditionalProperties"/>.
        /// </summary>
        public static readonly JsonEncodedText AdditionalPropertiesJsonPropertyName = JsonEncodedText.Encode( AdditionalPropertiesUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="UnevaluatedProperties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> UnevaluatedPropertiesUtf8JsonPropertyName = new byte[] { 117, 110, 101, 118, 97, 108, 117, 97, 116, 101, 100, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="UnevaluatedProperties"/>.
        /// </summary>
        public static readonly JsonEncodedText UnevaluatedPropertiesJsonPropertyName = JsonEncodedText.Encode( UnevaluatedPropertiesUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="Properties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> PropertiesUtf8JsonPropertyName = new byte[] { 112, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="Properties"/>.
        /// </summary>
        public static readonly JsonEncodedText PropertiesJsonPropertyName = JsonEncodedText.Encode( PropertiesUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="PatternProperties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> PatternPropertiesUtf8JsonPropertyName = new byte[] { 112, 97, 116, 116, 101, 114, 110, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="PatternProperties"/>.
        /// </summary>
        public static readonly JsonEncodedText PatternPropertiesJsonPropertyName = JsonEncodedText.Encode( PatternPropertiesUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="DependentSchemas"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> DependentSchemasUtf8JsonPropertyName = new byte[] { 100, 101, 112, 101, 110, 100, 101, 110, 116, 83, 99, 104, 101, 109, 97, 115 };

        /// <summary>
        /// JSON property name for <see cref="DependentSchemas"/>.
        /// </summary>
        public static readonly JsonEncodedText DependentSchemasJsonPropertyName = JsonEncodedText.Encode( DependentSchemasUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="PropertyNames"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> PropertyNamesUtf8JsonPropertyName = new byte[] { 112, 114, 111, 112, 101, 114, 116, 121, 78, 97, 109, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="PropertyNames"/>.
        /// </summary>
        public static readonly JsonEncodedText PropertyNamesJsonPropertyName = JsonEncodedText.Encode( PropertyNamesUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="If"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> IfUtf8JsonPropertyName = new byte[] { 105, 102 };

        /// <summary>
        /// JSON property name for <see cref="If"/>.
        /// </summary>
        public static readonly JsonEncodedText IfJsonPropertyName = JsonEncodedText.Encode( IfUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="Then"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ThenUtf8JsonPropertyName = new byte[] { 116, 104, 101, 110 };

        /// <summary>
        /// JSON property name for <see cref="Then"/>.
        /// </summary>
        public static readonly JsonEncodedText ThenJsonPropertyName = JsonEncodedText.Encode( ThenUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="Else"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ElseUtf8JsonPropertyName = new byte[] { 101, 108, 115, 101 };

        /// <summary>
        /// JSON property name for <see cref="Else"/>.
        /// </summary>
        public static readonly JsonEncodedText ElseJsonPropertyName = JsonEncodedText.Encode( ElseUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="AllOf"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> AllOfUtf8JsonPropertyName = new byte[] { 97, 108, 108, 79, 102 };

        /// <summary>
        /// JSON property name for <see cref="AllOf"/>.
        /// </summary>
        public static readonly JsonEncodedText AllOfJsonPropertyName = JsonEncodedText.Encode( AllOfUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="AnyOf"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> AnyOfUtf8JsonPropertyName = new byte[] { 97, 110, 121, 79, 102 };

        /// <summary>
        /// JSON property name for <see cref="AnyOf"/>.
        /// </summary>
        public static readonly JsonEncodedText AnyOfJsonPropertyName = JsonEncodedText.Encode( AnyOfUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="OneOf"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> OneOfUtf8JsonPropertyName = new byte[] { 111, 110, 101, 79, 102 };

        /// <summary>
        /// JSON property name for <see cref="OneOf"/>.
        /// </summary>
        public static readonly JsonEncodedText OneOfJsonPropertyName = JsonEncodedText.Encode( OneOfUtf8JsonPropertyName.Span);

        
        /// <summary>
        /// JSON property name for <see cref="Not"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> NotUtf8JsonPropertyName = new byte[] { 110, 111, 116 };

        /// <summary>
        /// JSON property name for <see cref="Not"/>.
        /// </summary>
        public static readonly JsonEncodedText NotJsonPropertyName = JsonEncodedText.Encode( NotUtf8JsonPropertyName.Span);

        
    
    
    
    
    
            private static readonly ImmutableDictionary<JsonEncodedText, Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>> __MenesLocalProperties = CreateLocalPropertyValidators();
    
            private static readonly ImmutableDictionary<JsonEncodedText, JsonAny> __MenesDefaults = BuildDefaults();
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<JsonEncodedText, JsonAny>? objectBacking;
    
    
    
    
            private readonly bool? booleanBacking;
    
        /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public Applicator(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                                this.booleanBacking = default;
            }

            /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public Applicator(ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                            this.booleanBacking = default;
                }

        /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public Applicator(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                            this.booleanBacking = default;
                }
    
    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="jsonBoolean">The <see cref="JsonBoolean"/> from which to construct the value.</param>
        public Applicator(JsonBoolean jsonBoolean)
        {
            if (jsonBoolean.HasJsonElement)
            {
                this.jsonElementBacking = jsonBoolean.AsJsonElement;
                this.booleanBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.booleanBacking = jsonBoolean.GetBoolean();
            }

                    this.objectBacking = default;
                                        }

                /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="boolean">The <see cref="bool"/> from which to construct the value.</param>
        public Applicator(bool boolean)
        {
            this.jsonElementBacking = default;
            this.booleanBacking = boolean;

                    this.objectBacking = default;
                                        }

    
    
    

    
    
            
        /// <summary>
        /// Gets AdditionalItems.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema AdditionalItems
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(AdditionalItemsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(AdditionalItemsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets UnevaluatedItems.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema UnevaluatedItems
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(UnevaluatedItemsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(UnevaluatedItemsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Items.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Applicator.ItemsEntity Items
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(ItemsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ItemsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Applicator.ItemsEntity(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Contains.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema Contains
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(ContainsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ContainsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets AdditionalProperties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema AdditionalProperties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(AdditionalPropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(AdditionalPropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets UnevaluatedProperties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema UnevaluatedProperties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(UnevaluatedPropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(UnevaluatedPropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Properties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Applicator.PropertiesValue Properties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(PropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(PropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Applicator.PropertiesValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets PatternProperties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Applicator.PatternPropertiesValue PatternProperties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(PatternPropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(PatternPropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Applicator.PatternPropertiesValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets DependentSchemas.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Applicator.DependentSchemasValue DependentSchemas
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(DependentSchemasJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(DependentSchemasUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Applicator.DependentSchemasValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets PropertyNames.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema PropertyNames
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(PropertyNamesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(PropertyNamesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets If.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema If
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(IfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(IfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Then.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema Then
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(ThenJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ThenUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Else.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema Else
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(ElseJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ElseUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets AllOf.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Applicator.SchemaArray AllOf
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(AllOfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(AllOfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Applicator.SchemaArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets AnyOf.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Applicator.SchemaArray AnyOf
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(AnyOfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(AnyOfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Applicator.SchemaArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets OneOf.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Applicator.SchemaArray OneOf
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(OneOfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(OneOfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Applicator.SchemaArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Not.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Menes.Json.Schema Not
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
                {
                    if(properties.TryGetValue(NotJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(NotUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Menes.Json.Schema(result);
                    }
                }

                return default;
            }
        }

                    /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                                    &&
                    this.booleanBacking is null
    
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return JsonBoolean.BoolToJsonElement(booleanBacking);
                }

    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return booleanBacking ? JsonValueKind.True : JsonValueKind.False;
                }

    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonAny(booleanBacking);
                }

    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonBoolean(booleanBacking);
                }
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new Applicator(value.AsJsonElement);
            }

            return value.As<Applicator>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(Applicator value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator(JsonObject value)
        {
            return new Applicator(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(Applicator value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<JsonEncodedText, JsonAny>(Applicator  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator (ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            return new Applicator (value);
        }

    
    
    
    
        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator(bool value)
        {
            return new Applicator(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator bool(Applicator boolean)
        {
            return boolean.AsBoolean.GetBoolean();
        }

        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator(JsonBoolean value)
        {
            return new Applicator(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator JsonBoolean(Applicator boolean)
        {
            return boolean.AsBoolean;
        }

    
            /// <summary>
        /// Creates an instance of a <see cref="Applicator"/>.
        /// </summary>
        public static Applicator Create(
                            Menes.Json.Schema? additionalItems = null
        ,             Menes.Json.Schema? unevaluatedItems = null
        ,             Menes.Json.Applicator.ItemsEntity? items = null
        ,             Menes.Json.Schema? contains = null
        ,             Menes.Json.Schema? additionalProperties = null
        ,             Menes.Json.Schema? unevaluatedProperties = null
        ,             Menes.Json.Applicator.PropertiesValue? properties = null
        ,             Menes.Json.Applicator.PatternPropertiesValue? patternProperties = null
        ,             Menes.Json.Applicator.DependentSchemasValue? dependentSchemas = null
        ,             Menes.Json.Schema? propertyNames = null
        ,             Menes.Json.Schema? @if = null
        ,             Menes.Json.Schema? then = null
        ,             Menes.Json.Schema? @else = null
        ,             Menes.Json.Applicator.SchemaArray? allOf = null
        ,             Menes.Json.Applicator.SchemaArray? anyOf = null
        ,             Menes.Json.Applicator.SchemaArray? oneOf = null
        ,             Menes.Json.Schema? not = null
                )
        {
            var builder = ImmutableDictionary.CreateBuilder<JsonEncodedText, JsonAny>();
                            if (additionalItems is Menes.Json.Schema additionalItems__)
            {
                builder.Add(AdditionalItemsJsonPropertyName, additionalItems__);
            }
                    if (unevaluatedItems is Menes.Json.Schema unevaluatedItems__)
            {
                builder.Add(UnevaluatedItemsJsonPropertyName, unevaluatedItems__);
            }
                    if (items is Menes.Json.Applicator.ItemsEntity items__)
            {
                builder.Add(ItemsJsonPropertyName, items__);
            }
                    if (contains is Menes.Json.Schema contains__)
            {
                builder.Add(ContainsJsonPropertyName, contains__);
            }
                    if (additionalProperties is Menes.Json.Schema additionalProperties__)
            {
                builder.Add(AdditionalPropertiesJsonPropertyName, additionalProperties__);
            }
                    if (unevaluatedProperties is Menes.Json.Schema unevaluatedProperties__)
            {
                builder.Add(UnevaluatedPropertiesJsonPropertyName, unevaluatedProperties__);
            }
                    if (properties is Menes.Json.Applicator.PropertiesValue properties__)
            {
                builder.Add(PropertiesJsonPropertyName, properties__);
            }
                    if (patternProperties is Menes.Json.Applicator.PatternPropertiesValue patternProperties__)
            {
                builder.Add(PatternPropertiesJsonPropertyName, patternProperties__);
            }
                    if (dependentSchemas is Menes.Json.Applicator.DependentSchemasValue dependentSchemas__)
            {
                builder.Add(DependentSchemasJsonPropertyName, dependentSchemas__);
            }
                    if (propertyNames is Menes.Json.Schema propertyNames__)
            {
                builder.Add(PropertyNamesJsonPropertyName, propertyNames__);
            }
                    if (@if is Menes.Json.Schema @if__)
            {
                builder.Add(IfJsonPropertyName, @if__);
            }
                    if (then is Menes.Json.Schema then__)
            {
                builder.Add(ThenJsonPropertyName, then__);
            }
                    if (@else is Menes.Json.Schema @else__)
            {
                builder.Add(ElseJsonPropertyName, @else__);
            }
                    if (allOf is Menes.Json.Applicator.SchemaArray allOf__)
            {
                builder.Add(AllOfJsonPropertyName, allOf__);
            }
                    if (anyOf is Menes.Json.Applicator.SchemaArray anyOf__)
            {
                builder.Add(AnyOfJsonPropertyName, anyOf__);
            }
                    if (oneOf is Menes.Json.Applicator.SchemaArray oneOf__)
            {
                builder.Add(OneOfJsonPropertyName, oneOf__);
            }
                    if (not is Menes.Json.Schema not__)
            {
                builder.Add(NotJsonPropertyName, not__);
            }
                    return builder.ToImmutable();
        }

        
        /// <summary>
        /// Sets additionalItems.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithAdditionalItems(Menes.Json.Schema value)
        {
            return this.SetProperty(AdditionalItemsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets unevaluatedItems.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithUnevaluatedItems(Menes.Json.Schema value)
        {
            return this.SetProperty(UnevaluatedItemsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets items.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithItems(Menes.Json.Applicator.ItemsEntity value)
        {
            return this.SetProperty(ItemsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets contains.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithContains(Menes.Json.Schema value)
        {
            return this.SetProperty(ContainsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets additionalProperties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithAdditionalProperties(Menes.Json.Schema value)
        {
            return this.SetProperty(AdditionalPropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets unevaluatedProperties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithUnevaluatedProperties(Menes.Json.Schema value)
        {
            return this.SetProperty(UnevaluatedPropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets properties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithProperties(Menes.Json.Applicator.PropertiesValue value)
        {
            return this.SetProperty(PropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets patternProperties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithPatternProperties(Menes.Json.Applicator.PatternPropertiesValue value)
        {
            return this.SetProperty(PatternPropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets dependentSchemas.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithDependentSchemas(Menes.Json.Applicator.DependentSchemasValue value)
        {
            return this.SetProperty(DependentSchemasJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets propertyNames.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithPropertyNames(Menes.Json.Schema value)
        {
            return this.SetProperty(PropertyNamesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets if.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithIf(Menes.Json.Schema value)
        {
            return this.SetProperty(IfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets then.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithThen(Menes.Json.Schema value)
        {
            return this.SetProperty(ThenJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets else.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithElse(Menes.Json.Schema value)
        {
            return this.SetProperty(ElseJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets allOf.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithAllOf(Menes.Json.Applicator.SchemaArray value)
        {
            return this.SetProperty(AllOfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets anyOf.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithAnyOf(Menes.Json.Applicator.SchemaArray value)
        {
            return this.SetProperty(AnyOfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets oneOf.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithOneOf(Menes.Json.Applicator.SchemaArray value)
        {
            return this.SetProperty(OneOfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets not.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithNot(Menes.Json.Schema value)
        {
            return this.SetProperty(NotJsonPropertyName, value);
        }

        
    

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
                if (this.booleanBacking is bool booleanBacking)
            {
                writer.WriteBooleanValue(booleanBacking);
                return;
            }
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(JsonEncodedText name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

                /// <inheritdoc/>
        public bool TryGetDefault(JsonEncodedText name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(string name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(JsonEncodedText.Encode(name), out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<char> name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(JsonEncodedText.Encode(name), out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(JsonEncodedText.Encode(utf8name), out value);
        }

        /// <inheritdoc/>
        public bool HasDefault(JsonEncodedText name)
        {
            return __MenesDefaults.TryGetValue(name, out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(string name)
        {
            return __MenesDefaults.TryGetValue(JsonEncodedText.Encode(name), out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<char> name)
        {
            return __MenesDefaults.TryGetValue(JsonEncodedText.Encode(name), out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<byte> utf8name)
        {
            return __MenesDefaults.TryGetValue(JsonEncodedText.Encode(utf8name), out _);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(Applicator other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(JsonEncodedText name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public Applicator SetProperty<TValue>(JsonEncodedText name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator RemoveProperty(JsonEncodedText name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<Applicator, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

    
    
            private static ImmutableDictionary<JsonEncodedText, JsonAny> BuildDefaults()
        {
            ImmutableDictionary<JsonEncodedText, JsonAny>.Builder builder =
                ImmutableDictionary.CreateBuilder<JsonEncodedText, JsonAny>();

                    builder.Add(PropertiesJsonPropertyName, JsonAny.Parse("{}"));
                    builder.Add(PatternPropertiesJsonPropertyName, JsonAny.Parse("{}"));
                    return builder.ToImmutable();
        }
    
    
    
        private static ImmutableDictionary<JsonEncodedText, Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>> CreateLocalPropertyValidators()
        {
            ImmutableDictionary<JsonEncodedText, Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>>.Builder builder =
                ImmutableDictionary.CreateBuilder<JsonEncodedText, Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>>();

                    builder.Add(
                AdditionalItemsJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.AdditionalItems;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                UnevaluatedItemsJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.UnevaluatedItems;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                ItemsJsonPropertyName,
                (that, validationContext, level) =>
                {
                    ItemsEntity property = that.Items;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                ContainsJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.Contains;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                AdditionalPropertiesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.AdditionalProperties;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                UnevaluatedPropertiesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.UnevaluatedProperties;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                PropertiesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    PropertiesValue property = that.Properties;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                PatternPropertiesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    PatternPropertiesValue property = that.PatternProperties;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                DependentSchemasJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DependentSchemasValue property = that.DependentSchemas;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                PropertyNamesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.PropertyNames;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                IfJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.If;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                ThenJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.Then;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                ElseJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.Else;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                AllOfJsonPropertyName,
                (that, validationContext, level) =>
                {
                    SchemaArray property = that.AllOf;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                AnyOfJsonPropertyName,
                (that, validationContext, level) =>
                {
                    SchemaArray property = that.AnyOf;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                OneOfJsonPropertyName,
                (that, validationContext, level) =>
                {
                    SchemaArray property = that.OneOf;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                NotJsonPropertyName,
                (that, validationContext, level) =>
                {
                    Schema property = that.Not;
                    return property.Validate(validationContext, level);
                });
        
            return builder.ToImmutable();
        }

    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

        
        
        
            foreach (Property property in this.EnumerateObject())
            {
                JsonEncodedText propertyName = property.NameAsJsonEncodedText;

        
                        if (__MenesLocalProperties.TryGetValue(propertyName, out Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>? propertyValidator))
                {
                    result = result.WithLocalProperty(propertyName);
                    result = propertyValidator(this, result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }

            
                }
        
        
        
        
        
        
                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
                
            ValidationContext localResultBoolean = Menes.Json.Validate.TypeBoolean(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultBoolean.IsValid)
            {
                return validationContext;
            }

            if (localResultBoolean.IsValid)
            {
                isValid = true;
            }

        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
                
                , localResultBoolean
        
                        );

            return result;
        }

    
    
    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct ItemsEntity :
            IJsonObject<ItemsEntity>,
                IJsonArray<ItemsEntity>,
                IEquatable<ItemsEntity>
    {
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<JsonEncodedText, JsonAny>? objectBacking;
    
            private readonly ImmutableList<JsonAny>? arrayBacking;
    
    
    
            private readonly bool? booleanBacking;
    
        /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public ItemsEntity(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                    this.arrayBacking = default;
                            this.booleanBacking = default;
            }

            /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public ItemsEntity(ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                    this.arrayBacking = default;
                                            this.booleanBacking = default;
                }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public ItemsEntity(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                    this.arrayBacking = default;
                                            this.booleanBacking = default;
                }
    
            /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="value">An array list.</param>
        public ItemsEntity(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
                    this.objectBacking = default;
                                            this.booleanBacking = default;
                    this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="jsonArray">The <see cref="JsonArray"/> from which to construct the value.</param>
        public ItemsEntity(JsonArray jsonArray)
        {
            if (jsonArray.HasJsonElement)
            {
                this.jsonElementBacking = jsonArray.AsJsonElement;
                this.arrayBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.arrayBacking = jsonArray.AsItemsList;
            }

                    this.objectBacking = default;
                                            this.booleanBacking = default;
                }
    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="jsonBoolean">The <see cref="JsonBoolean"/> from which to construct the value.</param>
        public ItemsEntity(JsonBoolean jsonBoolean)
        {
            if (jsonBoolean.HasJsonElement)
            {
                this.jsonElementBacking = jsonBoolean.AsJsonElement;
                this.booleanBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.booleanBacking = jsonBoolean.GetBoolean();
            }

                    this.objectBacking = default;
                            this.arrayBacking = default;
                                }

                /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="boolean">The <see cref="bool"/> from which to construct the value.</param>
        public ItemsEntity(bool boolean)
        {
            this.jsonElementBacking = default;
            this.booleanBacking = boolean;

                    this.objectBacking = default;
                            this.arrayBacking = default;
                                }

    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="conversion">The <see cref="Menes.Json.Schema"/> from which to construct the value.</param>
        public ItemsEntity(Menes.Json.Schema conversion)
        {
            if (conversion.HasJsonElement)
            {
                this.jsonElementBacking = conversion.AsJsonElement;
                        this.objectBacking = default;
                                this.booleanBacking = default;
        
                        this.arrayBacking = default;
                                    }
            else
            {
                this.jsonElementBacking = default;
                        if (conversion.ValueKind == JsonValueKind.Object)
                {
                    this.objectBacking = conversion;
                }
                else
                {
                    this.objectBacking = default;
                }
                                if (conversion.ValueKind == JsonValueKind.True || conversion.ValueKind == JsonValueKind.False)
                {
                    this.booleanBacking = conversion;
                }
                else
                {
                    this.booleanBacking = default;
                }
        
                        this.arrayBacking = default;
                                    }
        }
            /// <summary>
        /// Initializes a new instance of the <see cref="ItemsEntity"/> struct.
        /// </summary>
        /// <param name="conversion">The <see cref="Menes.Json.Applicator.SchemaArray"/> from which to construct the value.</param>
        public ItemsEntity(Menes.Json.Applicator.SchemaArray conversion)
        {
            if (conversion.HasJsonElement)
            {
                this.jsonElementBacking = conversion.AsJsonElement;
                        this.objectBacking = default;
                                this.booleanBacking = default;
        
                        this.arrayBacking = default;
                                    }
            else
            {
                this.jsonElementBacking = default;
                        this.objectBacking = default;
                                this.booleanBacking = default;
        
                        if (conversion.ValueKind == JsonValueKind.Array)
                {
                    this.arrayBacking = conversion;
                }
                else
                {
                    this.arrayBacking = default;
                }
                                    }
        }
    

            /// <inheritdoc/>
        public int Length
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> items)
                {
                    return items.Count;
                }

                return this.jsonElementBacking.GetArrayLength();
            }
        }
    
            /// <summary>
        /// Gets the value as a <see cref="Menes.Json.Schema" />.
        /// </summary>
        public Menes.Json.Schema AsSchema
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is a valid <see cref="Menes.Json.Schema" />.
        /// </summary>
        public bool IsSchema
        {
            get
            {
                return ((Menes.Json.Schema)this).Validate().IsValid;
            }
        }

            /// <summary>
        /// Gets the value as a <see cref="Menes.Json.Applicator.SchemaArray" />.
        /// </summary>
        public Menes.Json.Applicator.SchemaArray AsSchemaArray
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is a valid <see cref="Menes.Json.Applicator.SchemaArray" />.
        /// </summary>
        public bool IsSchemaArray
        {
            get
            {
                return ((Menes.Json.Applicator.SchemaArray)this).Validate().IsValid;
            }
        }

    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                        &&
                    this.arrayBacking is null
                                    &&
                    this.booleanBacking is null
    
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return JsonArray.ItemsToJsonElement(arrayBacking);
                }
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return JsonBoolean.BoolToJsonElement(booleanBacking);
                }

    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
                    if (this.arrayBacking is ImmutableList<JsonAny>)
                {
                    return JsonValueKind.Array;
                }

    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return booleanBacking ? JsonValueKind.True : JsonValueKind.False;
                }

    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonAny(arrayBacking);
                }

    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonAny(booleanBacking);
                }

    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonArray(arrayBacking);
                }

    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonBoolean(booleanBacking);
                }
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

            /// <summary>
        /// Conversion from <see cref="Menes.Json.Schema" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(Menes.Json.Schema value)
        {
            return new ItemsEntity(value);
        }

        /// <summary>
        /// Conversion to <see cref="Menes.Json.Schema" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Menes.Json.Schema(ItemsEntity value)
        {
                    if (value.ValueKind == JsonValueKind.Object)
            {
                return new Menes.Json.Schema(value.AsObject);
            }
                                            if (value.ValueKind == JsonValueKind.True || value.ValueKind == JsonValueKind.False)
            {
                return new Menes.Json.Schema(value.AsBoolean);
            }
                            return default;
        }
            /// <summary>
        /// Conversion from <see cref="Menes.Json.Applicator.SchemaArray" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(Menes.Json.Applicator.SchemaArray value)
        {
            return new ItemsEntity(value);
        }

        /// <summary>
        /// Conversion to <see cref="Menes.Json.Applicator.SchemaArray" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Menes.Json.Applicator.SchemaArray(ItemsEntity value)
        {
                            if (value.ValueKind == JsonValueKind.Array)
            {
                return new Menes.Json.Applicator.SchemaArray(value.AsArray);
            }
                                            return default;
        }
    
                /// <summary>
        /// Conversion from <see cref="Menes.Json.Core" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(Menes.Json.Core value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }

        /// <summary>
        /// Conversion to <see cref="Menes.Json.Core" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Menes.Json.Core(ItemsEntity value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }
            /// <summary>
        /// Conversion from <see cref="Menes.Json.Applicator" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(Menes.Json.Applicator value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }

        /// <summary>
        /// Conversion to <see cref="Menes.Json.Applicator" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Menes.Json.Applicator(ItemsEntity value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }
            /// <summary>
        /// Conversion from <see cref="Menes.Json.Validation" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(Menes.Json.Validation value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }

        /// <summary>
        /// Conversion to <see cref="Menes.Json.Validation" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Menes.Json.Validation(ItemsEntity value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }
            /// <summary>
        /// Conversion from <see cref="Menes.Json.MetaData" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(Menes.Json.MetaData value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }

        /// <summary>
        /// Conversion to <see cref="Menes.Json.MetaData" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Menes.Json.MetaData(ItemsEntity value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }
            /// <summary>
        /// Conversion from <see cref="Menes.Json.Format" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(Menes.Json.Format value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }

        /// <summary>
        /// Conversion to <see cref="Menes.Json.Format" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Menes.Json.Format(ItemsEntity value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }
            /// <summary>
        /// Conversion from <see cref="Menes.Json.Content" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(Menes.Json.Content value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }

        /// <summary>
        /// Conversion to <see cref="Menes.Json.Content" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Menes.Json.Content(ItemsEntity value)
        {
            return (Menes.Json.Applicator.ItemsEntity)value;
        }
    
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new ItemsEntity(value.AsJsonElement);
            }

            return value.As<ItemsEntity>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(ItemsEntity value)
        {
            return value.AsAny;
        }

    
        /// <summary>
        /// Conversion from array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(JsonArray value)
        {
            return new ItemsEntity(value);
        }

        /// <summary>
        /// Conversion to array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonArray(ItemsEntity value)
        {
            return value.AsArray;
        }
       
        /// <summary>
        /// Implicit conversion to an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(ItemsEntity value)
        {
            return value.AsArray.AsItemsList;
        }

        /// <summary>
        /// Implicit conversion from an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(ImmutableList<JsonAny> value)
        {
            return new ItemsEntity(value);
        }
    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(JsonObject value)
        {
            return new ItemsEntity(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(ItemsEntity value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<JsonEncodedText, JsonAny>(ItemsEntity  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity (ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            return new ItemsEntity (value);
        }

    
    
    
    
        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(bool value)
        {
            return new ItemsEntity(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator bool(ItemsEntity boolean)
        {
            return boolean.AsBoolean.GetBoolean();
        }

        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ItemsEntity(JsonBoolean value)
        {
            return new ItemsEntity(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator JsonBoolean(ItemsEntity boolean)
        {
            return boolean.AsBoolean;
        }

    
    

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
            {
                JsonArray.WriteItems(arrayBacking, writer);
                return;
            }

    
    
    
                if (this.booleanBacking is bool booleanBacking)
            {
                writer.WriteBooleanValue(booleanBacking);
                return;
            }
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
                /// <summary>
        /// Enumerate the items in the array as a <see cref="Menes.Json.JsonAny" />.
        /// </summary>
        public JsonArrayEnumerator<Menes.Json.JsonAny> EnumerateItems()
        {
            if (this.arrayBacking is ImmutableList<JsonAny> items)
            {
                return new JsonArrayEnumerator<Menes.Json.JsonAny>(items);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return new JsonArrayEnumerator<Menes.Json.JsonAny>(this.jsonElementBacking);
            }

            return default;
        }
                /// <inheritdoc/>
        public JsonArrayEnumerator EnumerateArray()
        {
            return this.AsArray.EnumerateArray();
        }
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(JsonEncodedText name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(ItemsEntity other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(JsonEncodedText name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public ItemsEntity SetProperty<TValue>(JsonEncodedText name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity RemoveProperty(JsonEncodedText name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public ItemsEntity Add<TItem>(TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity Insert<TItem>(int index, TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Insert(index, item);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity Replace<TItem>(TItem oldValue, TItem newValue)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.Replace(oldValue, newValue);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity RemoveAt(int index)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveAt(index);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity RemoveRange(int index, int count)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveRange(index, count);
            }

            return this;
        }

        /// <inheritdoc/>
        public ItemsEntity SetItem<TItem>(int index, TItem value)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.SetItem(index, value);
            }

            return this;
        }

    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<ItemsEntity, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }

    
    
    
    
    
        
    
    
    
    
                result = this.ValidateAnyOf(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    
    
    

                return result;
        }

    
    
    
    
    
    
    
    
            

            
        private ValidationContext ValidateAnyOf(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            bool foundValid = false;

                

            ValidationContext anyOfResult0 = this.As<Menes.Json.Schema>().Validate(validationContext.CreateChildContext(), level);

            if (anyOfResult0.IsValid)
            {
                result = result.MergeChildContext(anyOfResult0, level >= ValidationLevel.Detailed);
                            if (level == ValidationLevel.Flag)
                {
                    return result;
                }
                else
                {
                    foundValid = true;
                }
                        }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult0);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult0);
                }
            }

                

            ValidationContext anyOfResult1 = this.As<Menes.Json.Applicator.SchemaArray>().Validate(validationContext.CreateChildContext(), level);

            if (anyOfResult1.IsValid)
            {
                result = result.MergeChildContext(anyOfResult1, level >= ValidationLevel.Detailed);
                            if (level == ValidationLevel.Flag)
                {
                    return result;
                }
                else
                {
                    foundValid = true;
                }
                        }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult1);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult1);
                }
            }

        
            if (foundValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: true, "Validation 10.2.1.2. anyOf - validated against the anyOf schema.");
                }
            }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.2. anyOf - failed to validate against the anyOf schema.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.2. anyOf - failed to validate against the anyOf schema.");
                }
                else
                {
                    result = result.WithResult(isValid: false);
                }
            }

            return result;
        }

            

            

            

    
    
    
    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct PropertiesValue :
            IJsonObject<PropertiesValue>,
                    IEquatable<PropertiesValue>
    {
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<JsonEncodedText, JsonAny>? objectBacking;
    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="PropertiesValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public PropertiesValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                            }

            /// <summary>
        /// Initializes a new instance of the <see cref="PropertiesValue"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public PropertiesValue(ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PropertiesValue"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public PropertiesValue(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                        }
    
    
    
    
    
    
    

    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PropertiesValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new PropertiesValue(value.AsJsonElement);
            }

            return value.As<PropertiesValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(PropertiesValue value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PropertiesValue(JsonObject value)
        {
            return new PropertiesValue(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(PropertiesValue value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<JsonEncodedText, JsonAny>(PropertiesValue  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PropertiesValue (ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            return new PropertiesValue (value);
        }

    
    
    
    
    

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(JsonEncodedText name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(PropertiesValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(JsonEncodedText name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public PropertiesValue SetProperty<TValue>(JsonEncodedText name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue RemoveProperty(JsonEncodedText name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<PropertiesValue, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

    
    
    
    
    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

                    result = result.UsingEvaluatedProperties();
        
        
        
            foreach (Property property in this.EnumerateObject())
            {
                JsonEncodedText propertyName = property.NameAsJsonEncodedText;

        
        
        
        
                        if (!result.HasEvaluatedLocalProperty(propertyName))
                {
                    result = property.ValueAs<Menes.Json.Schema>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                    result = result.WithLocalProperty(propertyName);
                }
        
        
        
                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct PatternPropertiesValue :
            IJsonObject<PatternPropertiesValue>,
                    IEquatable<PatternPropertiesValue>
    {
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<JsonEncodedText, JsonAny>? objectBacking;
    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="PatternPropertiesValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public PatternPropertiesValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                            }

            /// <summary>
        /// Initializes a new instance of the <see cref="PatternPropertiesValue"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public PatternPropertiesValue(ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PatternPropertiesValue"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public PatternPropertiesValue(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                        }
    
    
    
    
    
    
    

    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PatternPropertiesValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new PatternPropertiesValue(value.AsJsonElement);
            }

            return value.As<PatternPropertiesValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(PatternPropertiesValue value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PatternPropertiesValue(JsonObject value)
        {
            return new PatternPropertiesValue(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(PatternPropertiesValue value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<JsonEncodedText, JsonAny>(PatternPropertiesValue  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PatternPropertiesValue (ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            return new PatternPropertiesValue (value);
        }

    
    
    
    
    

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(JsonEncodedText name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(PatternPropertiesValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(JsonEncodedText name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public PatternPropertiesValue SetProperty<TValue>(JsonEncodedText name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue RemoveProperty(JsonEncodedText name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<PatternPropertiesValue, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

    
    
    
    
    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

                    result = result.UsingEvaluatedProperties();
        
        
        
            foreach (Property property in this.EnumerateObject())
            {
                JsonEncodedText propertyName = property.NameAsJsonEncodedText;

        
        
        
                        string propertyNameAsString = property.Name;

                            result = new JsonString(propertyNameAsString).As<Menes.Json.Applicator.PatternPropertiesValue.PropertyNamesEntity>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }
            
                    
                        if (!result.HasEvaluatedLocalProperty(propertyName))
                {
                    result = property.ValueAs<Menes.Json.Schema>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                    result = result.WithLocalProperty(propertyName);
                }
        
        
        
                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
        
                        );

            return result;
        }

    
    
    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct PropertyNamesEntity :
                    IJsonValue,
            IEquatable<PropertyNamesEntity>
    {
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="PropertyNamesEntity"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public PropertyNamesEntity(JsonElement value)
        {
            this.jsonElementBacking = value;
                            }

    
    
    
    
    
    
    

    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                
        true
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PropertyNamesEntity(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new PropertyNamesEntity(value.AsJsonElement);
            }

            return value.As<PropertyNamesEntity>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(PropertyNamesEntity value)
        {
            return value.AsAny;
        }

    
    
    
    
    
    

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(PropertyNamesEntity other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<PropertyNamesEntity, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }

    
                JsonValueKind valueKind = this.ValueKind;
    
    
        
                    result = this.ValidateFormat(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
    
    
    
        
    
    
    
    
    
    
    

                return result;
        }

    
    
    
    
    
    
    
    
            

            

            

            

    
    
            
        private ValidationContext ValidateFormat(JsonValueKind valueKind, ValidationContext result, ValidationLevel level)
        {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
                
            if (valueKind == JsonValueKind.String)
            {
                return Menes.Json.Validate.TypeRegex(this, result, level);
            }
        
        
        
        
        
        
        
            return result;
        }

    
    
    
    
    }
    

    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct DependentSchemasValue :
            IJsonObject<DependentSchemasValue>,
                    IEquatable<DependentSchemasValue>
    {
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<JsonEncodedText, JsonAny>? objectBacking;
    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="DependentSchemasValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public DependentSchemasValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                            }

            /// <summary>
        /// Initializes a new instance of the <see cref="DependentSchemasValue"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public DependentSchemasValue(ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DependentSchemasValue"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public DependentSchemasValue(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                        }
    
    
    
    
    
    
    

    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentSchemasValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new DependentSchemasValue(value.AsJsonElement);
            }

            return value.As<DependentSchemasValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(DependentSchemasValue value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentSchemasValue(JsonObject value)
        {
            return new DependentSchemasValue(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(DependentSchemasValue value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<JsonEncodedText, JsonAny>(DependentSchemasValue  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentSchemasValue (ImmutableDictionary<JsonEncodedText, JsonAny> value)
        {
            return new DependentSchemasValue (value);
        }

    
    
    
    
    

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(JsonEncodedText name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(DependentSchemasValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(JsonEncodedText name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<JsonEncodedText, JsonAny> properties)
            {
                return properties.TryGetValue(JsonEncodedText.Encode(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public DependentSchemasValue SetProperty<TValue>(JsonEncodedText name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue RemoveProperty(JsonEncodedText name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<DependentSchemasValue, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

    
    
    
    
    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

                    result = result.UsingEvaluatedProperties();
        
        
        
            foreach (Property property in this.EnumerateObject())
            {
                JsonEncodedText propertyName = property.NameAsJsonEncodedText;

        
        
        
        
                        if (!result.HasEvaluatedLocalProperty(propertyName))
                {
                    result = property.ValueAs<Menes.Json.Schema>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                    result = result.WithLocalProperty(propertyName);
                }
        
        
        
                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct SchemaArray :
                IJsonArray<SchemaArray>,
                IEquatable<SchemaArray>
    {
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
            private readonly ImmutableList<JsonAny>? arrayBacking;
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="SchemaArray"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public SchemaArray(JsonElement value)
        {
            this.jsonElementBacking = value;
                    this.arrayBacking = default;
                        }

    
            /// <summary>
        /// Initializes a new instance of the <see cref="SchemaArray"/> struct.
        /// </summary>
        /// <param name="value">An array list.</param>
        public SchemaArray(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
                                            this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SchemaArray"/> struct.
        /// </summary>
        /// <param name="jsonArray">The <see cref="JsonArray"/> from which to construct the value.</param>
        public SchemaArray(JsonArray jsonArray)
        {
            if (jsonArray.HasJsonElement)
            {
                this.jsonElementBacking = jsonArray.AsJsonElement;
                this.arrayBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.arrayBacking = jsonArray.AsItemsList;
            }

                                        }
    
    
    
    
    
    

            /// <inheritdoc/>
        public int Length
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> items)
                {
                    return items.Count;
                }

                return this.jsonElementBacking.GetArrayLength();
            }
        }
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                        this.arrayBacking is null
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return JsonArray.ItemsToJsonElement(arrayBacking);
                }
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny>)
                {
                    return JsonValueKind.Array;
                }

    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonAny(arrayBacking);
                }

    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonArray(arrayBacking);
                }

    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SchemaArray(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new SchemaArray(value.AsJsonElement);
            }

            return value.As<SchemaArray>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(SchemaArray value)
        {
            return value.AsAny;
        }

    
        /// <summary>
        /// Conversion from array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SchemaArray(JsonArray value)
        {
            return new SchemaArray(value);
        }

        /// <summary>
        /// Conversion to array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonArray(SchemaArray value)
        {
            return value.AsArray;
        }
       
        /// <summary>
        /// Implicit conversion to an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(SchemaArray value)
        {
            return value.AsArray.AsItemsList;
        }

        /// <summary>
        /// Implicit conversion from an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SchemaArray(ImmutableList<JsonAny> value)
        {
            return new SchemaArray(value);
        }
    
    
    
    
    
    

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
            {
                JsonArray.WriteItems(arrayBacking, writer);
                return;
            }

    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
                /// <summary>
        /// Enumerate the items in the array as a <see cref="Menes.Json.Schema" />.
        /// </summary>
        public JsonArrayEnumerator<Menes.Json.Schema> EnumerateItems()
        {
            if (this.arrayBacking is ImmutableList<JsonAny> items)
            {
                return new JsonArrayEnumerator<Menes.Json.Schema>(items);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return new JsonArrayEnumerator<Menes.Json.Schema>(this.jsonElementBacking);
            }

            return default;
        }
                /// <inheritdoc/>
        public JsonArrayEnumerator EnumerateArray()
        {
            return this.AsArray.EnumerateArray();
        }
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(SchemaArray other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public SchemaArray Add<TItem>(TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray Insert<TItem>(int index, TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Insert(index, item);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray Replace<TItem>(TItem oldValue, TItem newValue)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.Replace(oldValue, newValue);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray RemoveAt(int index)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveAt(index);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray RemoveRange(int index, int count)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveRange(index, count);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray SetItem<TItem>(int index, TItem value)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.SetItem(index, value);
            }

            return this;
        }

    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<SchemaArray, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
    

                result = this.ValidateArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
                return result;
        }

    
    
    
    
    
    
            private ValidationContext ValidateArray(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Array)
            {
                return result;
            }

         
            int arrayLength = 0;
         
        
                     JsonArrayEnumerator arrayEnumerator = this.EnumerateArray();

            while (arrayEnumerator.MoveNext())
            {
        
        
                        result = arrayEnumerator.Current.As<Menes.Json.Schema>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                result = result.WithLocalItemIndex(arrayLength);

        
                arrayLength++;
            }
        
        
                    if (arrayLength < 1)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.4.2. minItems - {arrayLength} is less than the minimum number of items 1.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.4.2. minItems - item count is less than the minimum number of items 1.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }

            }
        
        
            return result;
        }

    
    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
        
                
            ValidationContext localResultArray = Menes.Json.Validate.TypeArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultArray.IsValid)
            {
                return validationContext;
            }

            if (localResultArray.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
        
                
                , localResultArray
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    }
    }
    