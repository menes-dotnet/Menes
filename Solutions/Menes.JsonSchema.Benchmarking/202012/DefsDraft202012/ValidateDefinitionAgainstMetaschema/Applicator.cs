
    //------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Linq;
    using System.Text;
    using System.Text.Json;
    using System.Text.RegularExpressions;
    using Menes.Json;

        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct Applicator :
            IJsonObject<Applicator>,
                    IEquatable<Applicator>
    {

        
    
        
        /// <summary>
        /// JSON property name for <see cref="PrefixItems"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> PrefixItemsUtf8JsonPropertyName = new byte[] { 112, 114, 101, 102, 105, 120, 73, 116, 101, 109, 115 };

        /// <summary>
        /// JSON property name for <see cref="PrefixItems"/>.
        /// </summary>
        public static readonly string PrefixItemsJsonPropertyName = "prefixItems";

        
        /// <summary>
        /// JSON property name for <see cref="Items"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ItemsUtf8JsonPropertyName = new byte[] { 105, 116, 101, 109, 115 };

        /// <summary>
        /// JSON property name for <see cref="Items"/>.
        /// </summary>
        public static readonly string ItemsJsonPropertyName = "items";

        
        /// <summary>
        /// JSON property name for <see cref="Contains"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ContainsUtf8JsonPropertyName = new byte[] { 99, 111, 110, 116, 97, 105, 110, 115 };

        /// <summary>
        /// JSON property name for <see cref="Contains"/>.
        /// </summary>
        public static readonly string ContainsJsonPropertyName = "contains";

        
        /// <summary>
        /// JSON property name for <see cref="AdditionalProperties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> AdditionalPropertiesUtf8JsonPropertyName = new byte[] { 97, 100, 100, 105, 116, 105, 111, 110, 97, 108, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="AdditionalProperties"/>.
        /// </summary>
        public static readonly string AdditionalPropertiesJsonPropertyName = "additionalProperties";

        
        /// <summary>
        /// JSON property name for <see cref="Properties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> PropertiesUtf8JsonPropertyName = new byte[] { 112, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="Properties"/>.
        /// </summary>
        public static readonly string PropertiesJsonPropertyName = "properties";

        
        /// <summary>
        /// JSON property name for <see cref="PatternProperties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> PatternPropertiesUtf8JsonPropertyName = new byte[] { 112, 97, 116, 116, 101, 114, 110, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="PatternProperties"/>.
        /// </summary>
        public static readonly string PatternPropertiesJsonPropertyName = "patternProperties";

        
        /// <summary>
        /// JSON property name for <see cref="DependentSchemas"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> DependentSchemasUtf8JsonPropertyName = new byte[] { 100, 101, 112, 101, 110, 100, 101, 110, 116, 83, 99, 104, 101, 109, 97, 115 };

        /// <summary>
        /// JSON property name for <see cref="DependentSchemas"/>.
        /// </summary>
        public static readonly string DependentSchemasJsonPropertyName = "dependentSchemas";

        
        /// <summary>
        /// JSON property name for <see cref="PropertyNames"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> PropertyNamesUtf8JsonPropertyName = new byte[] { 112, 114, 111, 112, 101, 114, 116, 121, 78, 97, 109, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="PropertyNames"/>.
        /// </summary>
        public static readonly string PropertyNamesJsonPropertyName = "propertyNames";

        
        /// <summary>
        /// JSON property name for <see cref="If"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> IfUtf8JsonPropertyName = new byte[] { 105, 102 };

        /// <summary>
        /// JSON property name for <see cref="If"/>.
        /// </summary>
        public static readonly string IfJsonPropertyName = "if";

        
        /// <summary>
        /// JSON property name for <see cref="Then"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ThenUtf8JsonPropertyName = new byte[] { 116, 104, 101, 110 };

        /// <summary>
        /// JSON property name for <see cref="Then"/>.
        /// </summary>
        public static readonly string ThenJsonPropertyName = "then";

        
        /// <summary>
        /// JSON property name for <see cref="Else"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ElseUtf8JsonPropertyName = new byte[] { 101, 108, 115, 101 };

        /// <summary>
        /// JSON property name for <see cref="Else"/>.
        /// </summary>
        public static readonly string ElseJsonPropertyName = "else";

        
        /// <summary>
        /// JSON property name for <see cref="AllOf"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> AllOfUtf8JsonPropertyName = new byte[] { 97, 108, 108, 79, 102 };

        /// <summary>
        /// JSON property name for <see cref="AllOf"/>.
        /// </summary>
        public static readonly string AllOfJsonPropertyName = "allOf";

        
        /// <summary>
        /// JSON property name for <see cref="AnyOf"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> AnyOfUtf8JsonPropertyName = new byte[] { 97, 110, 121, 79, 102 };

        /// <summary>
        /// JSON property name for <see cref="AnyOf"/>.
        /// </summary>
        public static readonly string AnyOfJsonPropertyName = "anyOf";

        
        /// <summary>
        /// JSON property name for <see cref="OneOf"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> OneOfUtf8JsonPropertyName = new byte[] { 111, 110, 101, 79, 102 };

        /// <summary>
        /// JSON property name for <see cref="OneOf"/>.
        /// </summary>
        public static readonly string OneOfJsonPropertyName = "oneOf";

        
        /// <summary>
        /// JSON property name for <see cref="Not"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> NotUtf8JsonPropertyName = new byte[] { 110, 111, 116 };

        /// <summary>
        /// JSON property name for <see cref="Not"/>.
        /// </summary>
        public static readonly string NotJsonPropertyName = "not";

        
    
    
    
    
    
            private static readonly ImmutableDictionary<string, Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>> __MenesLocalProperties = CreateLocalPropertyValidators();
    
            private static readonly ImmutableDictionary<string, JsonAny> __MenesDefaults = BuildDefaults();
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<string, JsonAny>? objectBacking;
    
    
    
    
            private readonly bool? booleanBacking;
    
        /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public Applicator(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                                this.booleanBacking = default;
            }

            /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public Applicator(ImmutableDictionary<string, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                            this.booleanBacking = default;
                }

        /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public Applicator(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                            this.booleanBacking = default;
                }
    
    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="jsonBoolean">The <see cref="JsonBoolean"/> from which to construct the value.</param>
        public Applicator(JsonBoolean jsonBoolean)
        {
            if (jsonBoolean.HasJsonElement)
            {
                this.jsonElementBacking = jsonBoolean.AsJsonElement;
                this.booleanBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.booleanBacking = jsonBoolean.GetBoolean();
            }

                    this.objectBacking = default;
                                        }

                /// <summary>
        /// Initializes a new instance of the <see cref="Applicator"/> struct.
        /// </summary>
        /// <param name="boolean">The <see cref="bool"/> from which to construct the value.</param>
        public Applicator(bool boolean)
        {
            this.jsonElementBacking = default;
            this.booleanBacking = boolean;

                    this.objectBacking = default;
                                        }

    
    
    

    
    
    
            
        /// <summary>
        /// Gets PrefixItems.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray PrefixItems
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(PrefixItemsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(PrefixItemsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Items.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema Items
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(ItemsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ItemsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Contains.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema Contains
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(ContainsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ContainsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets AdditionalProperties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema AdditionalProperties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(AdditionalPropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(AdditionalPropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Properties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PropertiesValue Properties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(PropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(PropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PropertiesValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets PatternProperties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PatternPropertiesValue PatternProperties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(PatternPropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(PatternPropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PatternPropertiesValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets DependentSchemas.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.DependentSchemasValue DependentSchemas
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(DependentSchemasJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(DependentSchemasUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.DependentSchemasValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets PropertyNames.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema PropertyNames
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(PropertyNamesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(PropertyNamesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets If.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema If
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(IfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(IfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Then.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema Then
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(ThenJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ThenUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Else.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema Else
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(ElseJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ElseUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets AllOf.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray AllOf
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(AllOfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(AllOfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets AnyOf.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray AnyOf
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(AnyOfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(AnyOfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets OneOf.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray OneOf
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(OneOfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(OneOfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Not.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema Not
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(NotJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(NotUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema(result);
                    }
                }

                return default;
            }
        }

                    /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                                    &&
                    this.booleanBacking is null
    
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return JsonBoolean.BoolToJsonElement(booleanBacking);
                }

    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return booleanBacking ? JsonValueKind.True : JsonValueKind.False;
                }

    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonAny(booleanBacking);
                }

    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonBoolean(booleanBacking);
                }
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new Applicator(value.AsJsonElement);
            }

            return value.As<Applicator>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(Applicator value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator(JsonObject value)
        {
            return new Applicator(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(Applicator value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<string, JsonAny>(Applicator  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator (ImmutableDictionary<string, JsonAny> value)
        {
            return new Applicator (value);
        }

    
    
    
    
        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator(bool value)
        {
            return new Applicator(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator bool(Applicator boolean)
        {
            return boolean.AsBoolean.GetBoolean();
        }

        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Applicator(JsonBoolean value)
        {
            return new Applicator(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator JsonBoolean(Applicator boolean)
        {
            return boolean.AsBoolean;
        }

    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(Applicator lhs, Applicator rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(Applicator lhs, Applicator rhs)
        {
            return !lhs.Equals(rhs);
        }

    
            /// <summary>
        /// Creates an instance of a <see cref="Applicator"/>.
        /// </summary>
        public static Applicator Create(
                            DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray? prefixItems = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema? items = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema? contains = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema? additionalProperties = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PropertiesValue? properties = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PatternPropertiesValue? patternProperties = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.DependentSchemasValue? dependentSchemas = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema? propertyNames = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema? @if = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema? then = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema? @else = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray? allOf = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray? anyOf = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray? oneOf = null
        ,             DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema? not = null
        
        )
        {
            var builder = ImmutableDictionary.CreateBuilder<string, JsonAny>();
                            if (prefixItems is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray prefixItems__)
            {
                builder.Add(PrefixItemsJsonPropertyName, prefixItems__);
            }
                    if (items is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema items__)
            {
                builder.Add(ItemsJsonPropertyName, items__);
            }
                    if (contains is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema contains__)
            {
                builder.Add(ContainsJsonPropertyName, contains__);
            }
                    if (additionalProperties is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema additionalProperties__)
            {
                builder.Add(AdditionalPropertiesJsonPropertyName, additionalProperties__);
            }
                    if (properties is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PropertiesValue properties__)
            {
                builder.Add(PropertiesJsonPropertyName, properties__);
            }
                    if (patternProperties is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PatternPropertiesValue patternProperties__)
            {
                builder.Add(PatternPropertiesJsonPropertyName, patternProperties__);
            }
                    if (dependentSchemas is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.DependentSchemasValue dependentSchemas__)
            {
                builder.Add(DependentSchemasJsonPropertyName, dependentSchemas__);
            }
                    if (propertyNames is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema propertyNames__)
            {
                builder.Add(PropertyNamesJsonPropertyName, propertyNames__);
            }
                    if (@if is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema @if__)
            {
                builder.Add(IfJsonPropertyName, @if__);
            }
                    if (then is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema then__)
            {
                builder.Add(ThenJsonPropertyName, then__);
            }
                    if (@else is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema @else__)
            {
                builder.Add(ElseJsonPropertyName, @else__);
            }
                    if (allOf is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray allOf__)
            {
                builder.Add(AllOfJsonPropertyName, allOf__);
            }
                    if (anyOf is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray anyOf__)
            {
                builder.Add(AnyOfJsonPropertyName, anyOf__);
            }
                    if (oneOf is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray oneOf__)
            {
                builder.Add(OneOfJsonPropertyName, oneOf__);
            }
                    if (not is DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema not__)
            {
                builder.Add(NotJsonPropertyName, not__);
            }
                    return builder.ToImmutable();
        }

        
        /// <summary>
        /// Sets prefixItems.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithPrefixItems(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray value)
        {
            return this.SetProperty(PrefixItemsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets items.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithItems(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema value)
        {
            return this.SetProperty(ItemsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets contains.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithContains(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema value)
        {
            return this.SetProperty(ContainsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets additionalProperties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithAdditionalProperties(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema value)
        {
            return this.SetProperty(AdditionalPropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets properties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithProperties(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PropertiesValue value)
        {
            return this.SetProperty(PropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets patternProperties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithPatternProperties(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PatternPropertiesValue value)
        {
            return this.SetProperty(PatternPropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets dependentSchemas.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithDependentSchemas(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.DependentSchemasValue value)
        {
            return this.SetProperty(DependentSchemasJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets propertyNames.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithPropertyNames(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema value)
        {
            return this.SetProperty(PropertyNamesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets if.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithIf(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema value)
        {
            return this.SetProperty(IfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets then.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithThen(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema value)
        {
            return this.SetProperty(ThenJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets else.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithElse(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema value)
        {
            return this.SetProperty(ElseJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets allOf.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithAllOf(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray value)
        {
            return this.SetProperty(AllOfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets anyOf.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithAnyOf(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray value)
        {
            return this.SetProperty(AnyOfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets oneOf.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithOneOf(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray value)
        {
            return this.SetProperty(OneOfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets not.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Applicator WithNot(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema value)
        {
            return this.SetProperty(NotJsonPropertyName, value);
        }

        
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is Applicator entity)
            {
                return this.Equals(entity);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.GetHashCode(),
                JsonValueKind.Array => this.AsArray.GetHashCode(),
                JsonValueKind.Number => this.AsNumber.GetHashCode(),
                JsonValueKind.String => this.AsString.GetHashCode(),
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
                JsonValueKind.Null => JsonNull.NullHashCode,
                _ => 0,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
                if (this.booleanBacking is bool booleanBacking)
            {
                writer.WriteBooleanValue(booleanBacking);
                return;
            }
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
        
        
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

                /// <inheritdoc/>
        public bool TryGetDefault(string name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<char> name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(name.ToString(), out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return __MenesDefaults.TryGetValue(Encoding.UTF8.GetString(utf8name), out value);
        }

        /// <inheritdoc/>
        public bool HasDefault(string name)
        {
            return __MenesDefaults.TryGetValue(name, out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<char> name)
        {
            return __MenesDefaults.TryGetValue(name.ToString(), out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<byte> utf8name)
        {
            return __MenesDefaults.TryGetValue(Encoding.UTF8.GetString(utf8name), out _);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(Applicator other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name.ToString(), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(Encoding.UTF8.GetString(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public Applicator SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Applicator RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<Applicator, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

    
    
            private static ImmutableDictionary<string, JsonAny> BuildDefaults()
        {
            ImmutableDictionary<string, JsonAny>.Builder builder =
                ImmutableDictionary.CreateBuilder<string, JsonAny>();

                    builder.Add(PropertiesJsonPropertyName, JsonAny.Parse("{}"));
                    builder.Add(PatternPropertiesJsonPropertyName, JsonAny.Parse("{}"));
                    builder.Add(DependentSchemasJsonPropertyName, JsonAny.Parse("{}"));
                    return builder.ToImmutable();
        }
    
    
    
        private static ImmutableDictionary<string, Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>> CreateLocalPropertyValidators()
        {
            ImmutableDictionary<string, Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>>.Builder builder =
                ImmutableDictionary.CreateBuilder<string, Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>>();

                    builder.Add(
                PrefixItemsJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray property = that.PrefixItems;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                ItemsJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema property = that.Items;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                ContainsJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema property = that.Contains;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                AdditionalPropertiesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema property = that.AdditionalProperties;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                PropertiesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PropertiesValue property = that.Properties;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                PatternPropertiesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PatternPropertiesValue property = that.PatternProperties;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                DependentSchemasJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.DependentSchemasValue property = that.DependentSchemas;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                PropertyNamesJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema property = that.PropertyNames;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                IfJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema property = that.If;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                ThenJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema property = that.Then;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                ElseJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema property = that.Else;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                AllOfJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray property = that.AllOf;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                AnyOfJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray property = that.AnyOf;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                OneOfJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.SchemaArray property = that.OneOf;
                    return property.Validate(validationContext, level);
                });
                    builder.Add(
                NotJsonPropertyName,
                (that, validationContext, level) =>
                {
                    DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema property = that.Not;
                    return property.Validate(validationContext, level);
                });
        
            return builder.ToImmutable();
        }

    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

        
        
            foreach (Property property in this.EnumerateObject())
            {
                string propertyName = property.Name;

        
                        if (__MenesLocalProperties.TryGetValue(propertyName, out Func<Applicator, ValidationContext, ValidationLevel, ValidationContext>? propertyValidator))
                {
                    result = result.WithLocalProperty(propertyName);
                    var propertyResult = propertyValidator(this, result, level);
                    result = result.MergeResults(propertyResult.IsValid, level, propertyResult);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }

            
                }
        
        
        
        
        
        
                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
                
            ValidationContext localResultBoolean = Menes.Json.Validate.TypeBoolean(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultBoolean.IsValid)
            {
                return validationContext;
            }

            if (localResultBoolean.IsValid)
            {
                isValid = true;
            }

        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
                
                , localResultBoolean
        
                        );

            return result;
        }

    
    
    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct SchemaArray :
                IJsonArray<SchemaArray>,
                IEquatable<SchemaArray>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
            private readonly ImmutableList<JsonAny>? arrayBacking;
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="SchemaArray"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public SchemaArray(JsonElement value)
        {
            this.jsonElementBacking = value;
                    this.arrayBacking = default;
                        }

    
            /// <summary>
        /// Initializes a new instance of the <see cref="SchemaArray"/> struct.
        /// </summary>
        /// <param name="value">An array list.</param>
        public SchemaArray(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
                                            this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SchemaArray"/> struct.
        /// </summary>
        /// <param name="jsonArray">The <see cref="JsonArray"/> from which to construct the value.</param>
        public SchemaArray(JsonArray jsonArray)
        {
            if (jsonArray.HasJsonElement)
            {
                this.jsonElementBacking = jsonArray.AsJsonElement;
                this.arrayBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.arrayBacking = jsonArray.AsItemsList;
            }

                                        }
    
    
    
    
    
    

            /// <inheritdoc/>
        public int Length
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> items)
                {
                    return items.Count;
                }

                return this.jsonElementBacking.GetArrayLength();
            }
        }
    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                        this.arrayBacking is null
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return JsonArray.ItemsToJsonElement(arrayBacking);
                }
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny>)
                {
                    return JsonValueKind.Array;
                }

    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonAny(arrayBacking);
                }

    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonArray(arrayBacking);
                }

    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SchemaArray(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new SchemaArray(value.AsJsonElement);
            }

            return value.As<SchemaArray>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(SchemaArray value)
        {
            return value.AsAny;
        }

    
        /// <summary>
        /// Conversion from array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SchemaArray(JsonArray value)
        {
            return new SchemaArray(value);
        }

        /// <summary>
        /// Conversion to array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonArray(SchemaArray value)
        {
            return value.AsArray;
        }
       
        /// <summary>
        /// Implicit conversion to an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(SchemaArray value)
        {
            return value.AsArray.AsItemsList;
        }

        /// <summary>
        /// Implicit conversion from an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SchemaArray(ImmutableList<JsonAny> value)
        {
            return new SchemaArray(value);
        }
    
    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(SchemaArray lhs, SchemaArray rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(SchemaArray lhs, SchemaArray rhs)
        {
            return !lhs.Equals(rhs);
        }

                    /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="items">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SchemaArray From(params DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema[] items)
        {
            return new SchemaArray(items.Select(i => (JsonAny)i).ToImmutableList());
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SchemaArray From(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item1)
        {
            return new SchemaArray(ImmutableList.Create((JsonAny)item1));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SchemaArray From(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item1, DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item2)
        {
            return new SchemaArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SchemaArray From(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item1, DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item2, DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item3)
        {
            return new SchemaArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2, (JsonAny)item3));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <param name="item4">The fourth item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SchemaArray From(DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item1, DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item2, DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item3, DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema item4)
        {
            return new SchemaArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2, (JsonAny)item3, (JsonAny)item4));
        }
        
    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is SchemaArray entity)
            {
                return this.Equals(entity);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.GetHashCode(),
                JsonValueKind.Array => this.AsArray.GetHashCode(),
                JsonValueKind.Number => this.AsNumber.GetHashCode(),
                JsonValueKind.String => this.AsString.GetHashCode(),
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
                JsonValueKind.Null => JsonNull.NullHashCode,
                _ => 0,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
            {
                JsonArray.WriteItems(arrayBacking, writer);
                return;
            }

    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
                /// <summary>
        /// Enumerate the items in the array as a <see cref="DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema" />.
        /// </summary>
        public JsonArrayEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema> EnumerateItems()
        {
            if (this.arrayBacking is ImmutableList<JsonAny> items)
            {
                return new JsonArrayEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>(items);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return new JsonArrayEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>(this.jsonElementBacking);
            }

            return default;
        }
                /// <inheritdoc/>
        public JsonArrayEnumerator EnumerateArray()
        {
            return this.AsArray.EnumerateArray();
        }
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(SchemaArray other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public SchemaArray Add<TItem>(TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray Insert<TItem>(int index, TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Insert(index, item);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray Replace<TItem>(TItem oldValue, TItem newValue)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.Replace(oldValue, newValue);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray RemoveAt(int index)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveAt(index);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray RemoveRange(int index, int count)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveRange(index, count);
            }

            return this;
        }

        /// <inheritdoc/>
        public SchemaArray SetItem<TItem>(int index, TItem value)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.SetItem(index, value);
            }

            return this;
        }

    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<SchemaArray, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
    

                result = this.ValidateArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
                return result;
        }

    
    
    
    
    
    
            private ValidationContext ValidateArray(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Array)
            {
                return result;
            }

         
            int arrayLength = 0;
         
        
                     JsonArrayEnumerator arrayEnumerator = this.EnumerateArray();

            while (arrayEnumerator.MoveNext())
            {
        
        
                        result = arrayEnumerator.Current.As<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                result = result.WithLocalItemIndex(arrayLength);

        
                arrayLength++;
            }
        
        
                    if (arrayLength < 1)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.4.2. minItems - {arrayLength} is less than the minimum number of items 1.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.4.2. minItems - item count is less than the minimum number of items 1.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }

            }
        
        
            return result;
        }

    
    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
        
                
            ValidationContext localResultArray = Menes.Json.Validate.TypeArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultArray.IsValid)
            {
                return validationContext;
            }

            if (localResultArray.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
        
                
                , localResultArray
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct PropertiesValue :
            IJsonObject<PropertiesValue>,
                    IEquatable<PropertiesValue>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<string, JsonAny>? objectBacking;
    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="PropertiesValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public PropertiesValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                            }

            /// <summary>
        /// Initializes a new instance of the <see cref="PropertiesValue"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public PropertiesValue(ImmutableDictionary<string, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PropertiesValue"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public PropertiesValue(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                        }
    
    
    
    
    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PropertiesValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new PropertiesValue(value.AsJsonElement);
            }

            return value.As<PropertiesValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(PropertiesValue value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PropertiesValue(JsonObject value)
        {
            return new PropertiesValue(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(PropertiesValue value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<string, JsonAny>(PropertiesValue  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PropertiesValue (ImmutableDictionary<string, JsonAny> value)
        {
            return new PropertiesValue (value);
        }

    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(PropertiesValue lhs, PropertiesValue rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(PropertiesValue lhs, PropertiesValue rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is PropertiesValue entity)
            {
                return this.Equals(entity);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.GetHashCode(),
                JsonValueKind.Array => this.AsArray.GetHashCode(),
                JsonValueKind.Number => this.AsNumber.GetHashCode(),
                JsonValueKind.String => this.AsString.GetHashCode(),
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
                JsonValueKind.Null => JsonNull.NullHashCode,
                _ => 0,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
                /// <summary>
        /// Enumerate the object as the given item type
        /// </summary>
        public JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema> EnumerateProperties()
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return new JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>(properties);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return new JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>(this.jsonElementBacking);
            }

            return default;

        }
        
        
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(PropertiesValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name.ToString(), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(Encoding.UTF8.GetString(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public PropertiesValue SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PropertiesValue RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<PropertiesValue, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
                    result = result.UsingEvaluatedProperties();
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

    
    
    
    
    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

        
        
            foreach (Property property in this.EnumerateObject())
            {
                string propertyName = property.Name;

        
        
        
        
                        if (!result.HasEvaluatedLocalProperty(propertyName))
                {
                    result = property.ValueAs<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                    result = result.WithLocalProperty(propertyName);
                }
        
        
        
                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct PatternPropertiesValue :
            IJsonObject<PatternPropertiesValue>,
                    IEquatable<PatternPropertiesValue>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<string, JsonAny>? objectBacking;
    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="PatternPropertiesValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public PatternPropertiesValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                            }

            /// <summary>
        /// Initializes a new instance of the <see cref="PatternPropertiesValue"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public PatternPropertiesValue(ImmutableDictionary<string, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PatternPropertiesValue"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public PatternPropertiesValue(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                        }
    
    
    
    
    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PatternPropertiesValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new PatternPropertiesValue(value.AsJsonElement);
            }

            return value.As<PatternPropertiesValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(PatternPropertiesValue value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PatternPropertiesValue(JsonObject value)
        {
            return new PatternPropertiesValue(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(PatternPropertiesValue value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<string, JsonAny>(PatternPropertiesValue  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PatternPropertiesValue (ImmutableDictionary<string, JsonAny> value)
        {
            return new PatternPropertiesValue (value);
        }

    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(PatternPropertiesValue lhs, PatternPropertiesValue rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(PatternPropertiesValue lhs, PatternPropertiesValue rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is PatternPropertiesValue entity)
            {
                return this.Equals(entity);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.GetHashCode(),
                JsonValueKind.Array => this.AsArray.GetHashCode(),
                JsonValueKind.Number => this.AsNumber.GetHashCode(),
                JsonValueKind.String => this.AsString.GetHashCode(),
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
                JsonValueKind.Null => JsonNull.NullHashCode,
                _ => 0,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
                /// <summary>
        /// Enumerate the object as the given item type
        /// </summary>
        public JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema> EnumerateProperties()
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return new JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>(properties);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return new JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>(this.jsonElementBacking);
            }

            return default;

        }
        
        
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(PatternPropertiesValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name.ToString(), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(Encoding.UTF8.GetString(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public PatternPropertiesValue SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public PatternPropertiesValue RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<PatternPropertiesValue, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
                    result = result.UsingEvaluatedProperties();
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

    
    
    
    
    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

        
        
            foreach (Property property in this.EnumerateObject())
            {
                string propertyName = property.Name;

        
        
        
                        string propertyNameAsString = property.Name;

                            result = new JsonString(propertyNameAsString).As<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Applicator.PatternPropertiesValue.PropertyNamesEntity>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }
            
                    
                        if (!result.HasEvaluatedLocalProperty(propertyName))
                {
                    result = property.ValueAs<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                    result = result.WithLocalProperty(propertyName);
                }
        
        
        
                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
        
                        );

            return result;
        }

    
    
    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct PropertyNamesEntity :
                    IJsonValue,
            IEquatable<PropertyNamesEntity>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="PropertyNamesEntity"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public PropertyNamesEntity(JsonElement value)
        {
            this.jsonElementBacking = value;
                            }

    
    
    
    
    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                
        true
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator PropertyNamesEntity(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new PropertyNamesEntity(value.AsJsonElement);
            }

            return value.As<PropertyNamesEntity>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(PropertyNamesEntity value)
        {
            return value.AsAny;
        }

    
    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(PropertyNamesEntity lhs, PropertyNamesEntity rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(PropertyNamesEntity lhs, PropertyNamesEntity rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is PropertyNamesEntity entity)
            {
                return this.Equals(entity);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.GetHashCode(),
                JsonValueKind.Array => this.AsArray.GetHashCode(),
                JsonValueKind.Number => this.AsNumber.GetHashCode(),
                JsonValueKind.String => this.AsString.GetHashCode(),
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
                JsonValueKind.Null => JsonNull.NullHashCode,
                _ => 0,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(PropertyNamesEntity other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<PropertyNamesEntity, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
        
                    result = this.ValidateFormat(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
    
    
    
        
    
    
    
    
    
    
    

                return result;
        }

    
    
    
    
    
    
    
    
            

            

            

            

    
    
            
        private ValidationContext ValidateFormat(JsonValueKind valueKind, ValidationContext result, ValidationLevel level)
        {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
                
            if (valueKind == JsonValueKind.String)
            {
                return Menes.Json.Validate.TypeRegex(this, result, level);
            }
        
        
        
        
        
        
        
            return result;
        }

    
    
    
    
    }
    

    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct DependentSchemasValue :
            IJsonObject<DependentSchemasValue>,
                    IEquatable<DependentSchemasValue>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<string, JsonAny>? objectBacking;
    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="DependentSchemasValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public DependentSchemasValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                            }

            /// <summary>
        /// Initializes a new instance of the <see cref="DependentSchemasValue"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public DependentSchemasValue(ImmutableDictionary<string, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DependentSchemasValue"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public DependentSchemasValue(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                        }
    
    
    
    
    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        public JsonObject AsObject
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

    
                return new JsonObject(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        public JsonArray AsArray
        {
            get
            {
    
                return new JsonArray(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        public JsonNumber AsNumber
        {
            get
            {
                    return new JsonNumber(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        public JsonString AsString
        {
            get
            {
                    return new JsonString(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        public JsonBoolean AsBoolean
        {
            get
            {
                    return new JsonBoolean(this.jsonElementBacking);
            }
        }

        /// <summary>
        /// Gets the value as a <see cref="JsonNull"/>.
        /// </summary>
        public JsonNull AsNull
        {
            get
            {
                return default;
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentSchemasValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new DependentSchemasValue(value.AsJsonElement);
            }

            return value.As<DependentSchemasValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(DependentSchemasValue value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentSchemasValue(JsonObject value)
        {
            return new DependentSchemasValue(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(DependentSchemasValue value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<string, JsonAny>(DependentSchemasValue  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentSchemasValue (ImmutableDictionary<string, JsonAny> value)
        {
            return new DependentSchemasValue (value);
        }

    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(DependentSchemasValue lhs, DependentSchemasValue rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(DependentSchemasValue lhs, DependentSchemasValue rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is DependentSchemasValue entity)
            {
                return this.Equals(entity);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.GetHashCode(),
                JsonValueKind.Array => this.AsArray.GetHashCode(),
                JsonValueKind.Number => this.AsNumber.GetHashCode(),
                JsonValueKind.String => this.AsString.GetHashCode(),
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
                JsonValueKind.Null => JsonNull.NullHashCode,
                _ => 0,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
                /// <summary>
        /// Enumerate the object as the given item type
        /// </summary>
        public JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema> EnumerateProperties()
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return new JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>(properties);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return new JsonObjectEnumerator<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>(this.jsonElementBacking);
            }

            return default;

        }
        
        
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(DependentSchemasValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                JsonValueKind.String => this.AsString.Equals(other.AsString),
                JsonValueKind.Null => true,
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name.ToString(), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(Encoding.UTF8.GetString(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public DependentSchemasValue SetProperty<TValue>(string name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentSchemasValue RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<DependentSchemasValue, T>();
        }

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
                    result = result.UsingEvaluatedProperties();
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

    
    
    
    
    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

        
        
            foreach (Property property in this.EnumerateObject())
            {
                string propertyName = property.Name;

        
        
        
        
                        if (!result.HasEvaluatedLocalProperty(propertyName))
                {
                    result = property.ValueAs<DefsDraft202012Feature.ValidateDefinitionAgainstMetaschema.Schema>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                    result = result.WithLocalProperty(propertyName);
                }
        
        
        
                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Menes.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    }
    }
    