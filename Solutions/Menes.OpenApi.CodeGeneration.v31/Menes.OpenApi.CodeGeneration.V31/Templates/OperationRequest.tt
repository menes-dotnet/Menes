<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Corvus.Json" #>
<#
    // This is only emitted if true is true
    if(!ShouldGenerate)
    {
        throw new InvalidOperationException("Service should not be emitted if true is false.");
    } #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System.Text.Json;
using Corvus.Json;
using Corvus.UriTemplates;
using Menes.HttpHelpers;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Primitives;

namespace <#= Namespace #>;

<# BeginNesting(); #>
/// <summary>
/// Implements the request context for the operation with ID <#= OperationId #>.
/// </summary>
public readonly partial struct <#= RequestContextDotnetTypeName #> : IHttpContextProvider
{
    /// <summary>
    /// Initializes a new instance of the <see cref="<#= RequestContextDotnetTypeName #>"/> class.
    /// </summary>
    /// <param name="context">The HTTP context for the request.</param>
    public <#= RequestContextDotnetTypeName #>(HttpContext context, UriTemplate uriTemplate)
    {
        this.HttpContext = context;
        this.UriTemplate = uriTemplate;
    }

    /// <summary>
    /// Gets the current HTTP context.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This is only available for Menes hosting pipelines based on an ASPNET HttpContext.
    /// </para>
    /// <para>
    /// You should avoid depending on this in your <see cref=" <#= OperationFullyQualifiedDotnetTypeName #>.HandleRequest()" />
    /// implementation if you wish to be source-portable to other hosting environments.
    /// </para>
    /// </remarks>
    HttpContext IHttpContextProvider.HttpContext { get; }

    /// <summary>
    /// Gets the URI template for the request.
    /// </summary>
    public UriTemplate UriTemplate { get; }
<#  foreach (var parameter in RequestHeaderParameters)
    { #>

    /// <summary>
    /// Gets the <#= parameter.Name #> parameter.
    /// </summary>
    public <#= parameter.DotnetTypeName #> <#= parameter.DotnetPropertyName #>
    {
        get
        {
            return GetHeaderParameter<<#= parameter.DotnetTypeName #>>(<#= parameter.Name #>);
        }
    }
<#  }
    foreach (var parameter in RequestPathParameters)
    { #>

    /// <summary>
    /// Gets the <#= parameter.Name #> parameter.
    /// </summary>
    public <#= parameter.DotnetTypeName #> <#= parameter.DotnetPropertyName #>
    {
        get
        {
<#      if (parameter.IsSpaceDelimitedObjectStyleQueryParameter)
        { #>
            return GetSpaceDelimitedObjectStyleQueryParameter<<#= parameter.DotnetTypeName #>>("<#= parameter.Name #>");
<#      }
        else if (parameter.IsPipeDelimitedObjectStyleQueryParameter)
        { #>
            return GetPipeDelimitedObjectQueryParameter<<#= parameter.DotnetTypeName #>>("<#= parameter.Name #>");
<#      }
        else if (parameter.IsSpaceDelimitedArrayStyleQueryParameter)
        { #>
            return GetPipeDelimitedArrayStyleQueryParameter<<#= parameter.DotnetTypeName #>>("<#= parameter.Name #>");
<#      }
        else if (parameter.IsPipeDelimitedArrayQueryParameter)
        { #>
            return GetPipeDelimitedArrayStyleQueryParameter<<#= parameter.DotnetTypeName #>>("<#= parameter.Name #>");
<#      }
        else if (parameter.IsExplodedArrayStyleQueryParameter)
        {#>
            return GetExplodedArrayStyleQueryParameter<<#= parameter.DotnetTypeName #>>("<#= parameter.Name #>");
<#      }
        else if (parameter.IsExplodedObjectStyleQueryParameter)
        {#>
            return GetExplodedObjectStyleQueryParameter<<#= parameter.DotnetTypeName #>>("<#= parameter.Name #>");
<#      }
        else
        { #>
            return GetPathParameter(<#= parameter.Name #>);
<#      } #>
        }
    }
<#  foreach (var parameter in RequestCookieParameters)
    { #>

    /// <summary>
    /// Gets the <#= parameter.Name #> parameter.
    /// </summary>
    public <#= parameter.DotnetTypeName #> <#= parameter.DotnetPropertyName #>
    {
        get
        {
<#      if (parameter.IsExploded)
        { #>
            return GetExplodedCookieParameter<<#= parameter.DotnetTypeName #>>(<#= parameter.Name #>);
<#      }
        else
        { #>
            return GetCookieParameter<<#= parameter.DotnetTypeName #>>(<#= parameter.Name #>);
<#      } #>
        }
    }
<#  }
    if (RequestHasBody)
    {
        if (RequestBodyIsJsonMediaType)
        { #>

    /// <summary>
    /// Gets the request body.
    /// </summary>
    public <#= RequestBodyDotnetTypeName #> Body
    {
        get
        {
            return GetRequestBody<<#= RequestBodyDotnetTypeName #>>();
        }
    }
<#      }
        else
        { #>

    /// <summary>
    /// Process the request body.
    /// </summary>
    /// <typeparam name="T">The type of the caller-specified processing response.</typeparam>
    /// <param name="processor">A function which takes a PipeReader, and optional content length and content type, and produces a caller-specified response.</param>
    /// <returns>The result of processing the request body.</returns>
    public T ProcessRequestBody<T>(Func<PipeReader, long?, string?, T> processor)
    {
        return processor(this.HttpContext.HttpRequest.BodyReader, this.HttpContext.HttpRequest.ContentLength, this.HttpContext.HttpRequest.ContentType);
    }
<#      }
    } #>

<#  foreach(var response OperationResponses)
    { #>
    /// <summary>
    /// Creates a <#= response.Name #>.
    /// </summary>
    /// <returns>
    /// An instance of a <see cref="<#= response.DotnetTypeName #>" />;
    /// </returns>
    public <#= response.DotnetTypeName #> Create<#= response.Name #>(
<#  bool isFirstCreateParameter = true;
    foreach(var property in response.RequiredAllOfAndRefProperties)
    {
        if (!IsConst(property.Type))
        {
            if (isFirstCreateParameter)
            {
                isFirstCreateParameter = false;
            }
            else
            {
    #>, <#
            }
    #>
        <#= property.Type.FullyQualifiedDotnetTypeName #> <#= property.DotnetParameterName #>
<#      }
    }

    foreach(var property in response.OptionalAllOfAndRefProperties)
    {
        if (isFirstCreateParameter)
        {
            isFirstCreateParameter = false;
        }
        else
        {
    #>,<#
        }
    #>
        <#= property.Type.FullyQualifiedDotnetTypeName #>? <#= property.DotnetParameterName #> = null <#
    }
    #>)
    {
        return <#= response.DotnetTypeName #>.Create(
<#  bool isFirstCreateParameter = true;
    foreach(var property in response.RequiredAllOfAndRefProperties)
    {
        if (!IsConst(property.Type))
        {
            if (isFirstCreateParameter)
            {
                isFirstCreateParameter = false;
            }
            else
            {
    #>, <#
            }
    #>
            <#= property.DotnetParameterName #>
<#      }
    }

    foreach(var property in response.OptionalAllOfAndRefProperties)
    {
        if (isFirstCreateParameter)
        {
            isFirstCreateParameter = false;
        }
        else
        {
    #>,<#
        }
    #>
            <#= property.DotnetParameterName #><#
    }
    #>);
    }
<#  } #>

    private T GetRequestBody<T>()
        where T : struct, IJsonValue<T>
    {
        return T.FromJson(this.HttpContext.GetRequestBodyJsonDocument()).RootElement);
    }
<#  if (HasHeaderParameters)
    { #>

    private T GetHeaderParameter<T>(string headerName)
        where T : struct, IJsonValue<T>
    {
        if (this.HttpContext.Header.TryGetValue(headerName, out StringValues stringValues))
        {
            if (stringValues.Empty)
            {
                return T.Undefined;
            }

            if (stringValues.Count > 1)
            {
                return T.Undefined;
            }

            return Parsing.ParseSimpleStyleValue(stringValues).As<T>();
        }

        return T.Undefined;
    }
<#  if (HasCookieParameters)
    { #>

    private T GetCookieParameter<T>(string cookieName)
        where T : struct, IJsonValue<T>
    {
        if (context.Request.Cookies.TryGetValue(cookieName, out string? value))
        {
            if (value.IsNullOrEmpty())
            {
                return T.Undefined;
            }

            return Parsing.ParseFormStyleValue(value).As<T>();
        }

        return T.Undefined;
    }
<#  if (HasExpodedCookieParameters)
    { #>

    private T GetExplodedCookieParameter<T>(string cookieName)
        where T : struct, IJsonValue<T>
    {
        if (context.Request.Cookies.TryGetValue(cookieName, out string? value))
        {
            if (value.IsNullOrEmpty())
            {
                return T.Undefined;
            }

            return Parsing.ParseExplodedFormStyleValue(value).As<T>();
        }

        return T.Undefined;
    }
<#  }
    if (HasUriTemplateParameters)
    { #>

    private T GetPathParameter<T>(string parameterName)
        where T : struct, IJsonValue<T>
    {
        return this.HttpContext.GetPathParameter<T>(this.UriTemplateParser, parameterName);
    }
<#  }
    if (HasBasicQueryParameters)
    { #>

    private T GetQueryParameter<T>(string parameterName)
        where T : struct, IJsonValue<T>
    {
        return this.HttpContext.GetQueryParameter<T>(parameterName);
    }
<#  }
    if (HasExplodedObjectStyleQueryParameters)
    { #>

    private T GetExplodedObjectStyleQueryParameter<T>()
        where T : struct, IJsonValue<T>
    {
        return this.HttpContext.GetExplodedObjectStyleQueryParameter<T>();
    }
<#  }
    if (HasExplodedArrayStyleQueryParameters)
    { #>

    private T GetExplodedArrayStyleQueryParameter<T>(string parameterName)
        where T : struct, IJsonValue<T>
    {
        return this.HttpContext.GetExplodedArrayStyleQueryParameter<T>(parameterName);
    }
<#  }
    if (HasSpaceDelimitedQueryParameterForObject)
    { #>

    private T GetSpaceDelimitedObjectQueryParameter<T>(string parameterName)
        where T : struct, IJsonValue<T>
    {
        return this.HttpContext.GetSpaceDelimitedObjectStyleQueryParameter<T>(parameterName);
    }
<#  }
    if (HasPipeDelimitedQueryParameterForObject)
    { #>

    private T GetPipeDelimitedObjectQueryParameter<T>(string parameterName)
        where T : struct, IJsonValue<T>
    {
        return this.HttpContext.GetPipeDelimitedObjectStyleQueryParameter<T>(parameterName);
    }
<#  }
    if (HasSpaceDelimitedQueryParameterForArray)
    { #>

    private T GetSpaceDelimitedArrayStyleQueryParameter<T>(string parameterName)
        where T : struct, IJsonValue<T>
    {
        return this.HttpContext.GetSpaceDelimitedArrayStyleQueryParameter<T>(parameterName);
    }
<#  }
    if (HasPipeDelimitedQueryParameterForArray)
    { #>

    private T GetPipeDelimitedArrayStyleQueryParameter<T>(string parameterName)
        where T : struct, IJsonValue<T>
    {
        return this.HttpContext.GetPipeDelimitedArrayStyleQueryParameter<T>(parameterName);
    }
<#  } #>
}
<# EndNesting(); #>
<#+
    public bool ShouldGenerate
    {
        get
        {
            return true;
        }
    }
#>