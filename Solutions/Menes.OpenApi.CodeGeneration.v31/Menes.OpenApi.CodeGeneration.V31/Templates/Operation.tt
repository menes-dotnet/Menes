<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Corvus.Json" #>
<#
    // This is only emitted if true is true
    if(!ShouldGenerate)
    {
        throw new InvalidOperationException("Service should not be emitted if true is false.");
    } #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System.Text.Json;
using Corvus.Json;
using Menes.HttpHelpers;
using Microsoft.AspNetCore.Http;

namespace <#= Namespace #>;

<# BeginNesting(); #>
/// <summary>
/// Implements the operation with ID <#= OperationId #>.
/// </summary>
<#  if (OperationSummary.IsNotNullOrEmpty())
    { #>
/// <remarks>
/// <#= OperationSummary #>
/// </remarks>
<#  } #>
public readonly partial struct <#= OperationDotnetTypeName #> : I<#= OperationDotnetTypeName #>
{
<#  if (RequestHasMediaTypes)
    {
        foreach(var requestType in RequestTypes)
        { #>
    private static readonly Regex __MenesMediaTypeMatchFor<#= requestType.Name #> = new("<#= requestType.RegexString #>", RegexOptions.Compiled, TimeSpan.FromSeconds(1));

<#      }
    }#>
<#  if (ResponsesHaveMediaTypes)
    {
        foreach(var responseForMediaType in OperationResponsesForMediaTypes)
        { #>
    private static readonly Regex __MenesMediaTypeMatchFor<#= responseForMediaType.DotnetTypeName #> = new("<#= responseForMediaType.RegexString #>", RegexOptions.Compiled, TimeSpan.FromSeconds(1));

<#      }
    }#>
    /// <summary>
    /// ASPNET Core handler for the <#= OperationId #> operation.
    /// </summary>
    /// <param name="context">The ASPNET HttpContext.</param>
    /// <returns>A task which completes when the handler is complete.</returns>
    public async Task Handle(HttpContext context)
    {
<#  if (RequestHasMediaTypes)
    { #>
         <#= OperationResultDotnetTypeName #> result = <#= OperationResultDotnetTypeName #>.Undefined;
<#      int index = 0;
        foreach(var requestType in RequestTypes)
        { #>
        <#= index > 0 ? "else " : string.Empty #>if (this.HttpContext.MatchRequestContentType(__MenesMediaTypeMatchFor<#= requestType.Name #>))
        {
            <#= requestType.RequestContextDotnetTypeName #> requestContext = new(context);
            result = await this.HandleOperation(requestContext).ConfigureAwait(false);
        }
<#          index++;
        } #>

        if (result.IsUndefined())
        {
            throw new InvalidOperationException($"The media type {this.HttpContext.HttpRequest.ContentType} was not recognized by the handler.");
        }
<#    }
    else
    {#>
        <#= RequestContextDotnetTypeName #> requestContext = new(context);
        <#= OperationResultDotnetTypeName #> result = await this.HandleOperation(requestContext).ConfigureAwait(false);
<#  }#>

        context.Response.StatusCode = result.StatusCode;

<# /* NEED TO USE BOTH STATUS CODE AND POTENTIALLY MEDIA TYPE TO GET THE RESPONSE
    */ #>
        switch(result.StatusCode)
        {
<#  foreach (var response in OperationResponsesByStatusCode)
    { #>
<#      if (response.HasHeaders || response.HasBody)
        { #>
            case <#= response.StatusCode #>:
                if (!result.TryGetAs<#= response.DotnetTypeName #>(out <#= response.DotnetTypeName #> resultFor<#= response.StatusCode #>))
                {
                    throw new InvalidOperationException("The result for <#= response.StatusCode #> is not valid.");
                }

<#      if (response.HasHeaders)
        { #>
                this.HandleHeadersFor(context, resultFor<#= response.StatusCode #>);
<#      }
        if (response.HasBody)
        {#>
                this.HandleBodyFor(context, resultFor<#= response.StatusCode #>);
<#      } #>
                break;
<#      }
    } #>
            default:
                throw new InvalidOperationException($"Unrecognized status code {result.StatusCode} for operation <#= OperationId #>.");
        }
    }
<#  foreach (var response in OperationResponses)
    {
        if (response.HasHeaders)
        { #>
    private void HandleHeadersFor(HttpContext context, in <#= response.DotnetTypeName #> result)
    {
<#          foreach (var header in response.Headers)
            { #>
        if (result.Headers.TryGetProperty("<#= header.DotnetPropertyName #>", out JsonAny headerValue))
        {
            context.HttpResponse.Headers.Append("<#= header.Name #>", <#= header.FormatFunctionName #>(headerValue));
        }

<#          }
        } #>}

<#      if (response.HasBody)
        {#>
    private void HandleBodyFor(HttpContext context, in <#= response.DotnetTypeName #> result)
    {
<#          if (response.BodyIsFormUrlEncoded)
            { #>
        this.WriteFormUrlEncodedBodyContent(context.HttpResponse.BodyWriter, result);
<#          }
            else if (response.BodyIsMultipart)
            { #>
        this.WriteMultipartFormBodyContent(context.HttpResponse.BodyWriter, result);
<#          }
            else if (response.BodyIsNotJson)
            { #>
        this.WriteBodyContent(context.HttpResponse.BodyWriter, result);
<#          }
            else
            { #>
        Utf8JsonWriter writer = new(context.HttpResponse.BodyWriter, new() { SkipValidation = true; });
        result.Body.WriteTo(writer);
<#          } #>
    }
<#      }
    } #>

    /// <summary>
    /// Interface implemented by the <#= OperationDotnetTypeName #> operation handler.
    /// </summary>
    /// <remarks>
    /// Implementers will provide this method in the partial they create to implement the operation logic.
    /// </remarks>
    public interface I<#= OperationDotnetTypeName #>
    {
<#  if (RequestHasMediaTypes)
    { #>
<#      int index = 0;
        foreach(var requestType in RequestTypes)
        { #>

        /// <summary>
        /// Handle the request context and produce a result.
        /// </summary>
        /// <param name="requestContext">The request context.</param>
        /// <result>A task which, when complete, provides the operation result.</result>
        Task<<#= OperationResultDotnetTypeName #>> HandleOperation(in <# requestType.RequestContextDotnetTypeName #> requestContext);
<#      }
    }
    else
    { #>
        /// <summary>
        /// Handle the request context and produce a result.
        /// </summary>
        /// <param name="requestContext">The request context.</param>
        /// <result>A task which, when complete, provides the operation result.</result>
        Task<<#= OperationResultDotnetTypeName #>> HandleOperation(in <# RequestContextDotnetTypeName #> requestContext);
<#  }
    if (response.BodyIsMultipart)
    { #>

        /// <summary>
        /// Write multipart form encoded content to the response body.
        /// </summary>
        /// <param name="responseBodyWriter">The writer for the response body.</param>
        /// <param name="result">The operation result for which to write the multipart form content for the body.</param>
        void WriteMultipartFormBodyContent(IBufferWriter<byte> responseBodyWriter, <#= OperationResultDotnetTypeName #> result);
<#  }
    if (response.BodyIsFormUrlEncoded)
    { #>

        /// <summary>
        /// Write form URL encoded content to the response body.
        /// </summary>
        /// <param name="responseBodyWriter">The writer for the response body.</param>
        /// <param name="result">The operation result for which to write the form URL-encoded content for the body.</param>
        void WriteFormUrlEncodedBodyContent(IBufferWriter<byte> responseBodyWriter, <#= OperationResultDotnetTypeName #> result);
<#  }
    if (response.BodyIsNotJson)
    { #>

        /// <summary>
        /// Write form URL encoded content to the response body.
        /// </summary>
        /// <param name="responseBodyWriter">The writer for the response body.</param>
        /// <param name="result">The operation result for which to write the form URL-encoded content for the body.</param>
        void WriteBodyContent(IBufferWriter<byte> responseBodyWriter, <#= OperationResultDotnetTypeName #> result);
<#  } #>

    }
}
<# EndNesting(); #>
<#+
    public bool ShouldGenerate
    {
        get
        {
            return true;
        }
    }
#>